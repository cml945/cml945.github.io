<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT-1060解题报告]]></title>
    <url>%2Fpost%2FPAT_1060%2F</url>
    <content type="text"><![CDATA[1060 Are They Equal题目1060 Are They Equal （25 分）If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×10^5 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification:Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^​100, and that its total digit number is less than 100. Output Specification:For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]…d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1:3 12300 12358.9Sample Output 1:YES 0.12310^5Sample Input 2:3 120 128Sample Output 2:NO 0.12010^3 0.128*10^3 思路题目要求主要就是给定有效数字，把一个浮点数用科学记数法表示出来。数字有100位，所以基本只能用字符串来表示，并进行处理了。直接通过一次扫描，扫描的过程中把位数等信息保存下来。细节很多，很多小坑。容易出错的输入包括0.0001234, 0.00000等。to_string()可以把数字转换为字符串，很好用。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;string chop(string s,int sigDigits)&#123; string ret = "0."; bool isPositive = s[0]!='-'; int digit = 0; bool afterPoint = false; bool firstZero = true; for(int i = 1-isPositive;i&lt;s.size();i++)&#123; if(firstZero&amp;&amp;s[i]=='0') &#123; if(afterPoint) digit--; continue; &#125; if(s[i] == '.') &#123; afterPoint = true; continue; &#125; firstZero = false; if(ret.size()&lt;sigDigits+2) ret.push_back(s[i]); if(!afterPoint) digit++; &#125; if(firstZero) digit = 0;//数字为0则将位数置为0，否则输入0.000会出错 while(ret.size()&lt;sigDigits+2) ret+="0"; ret+= "*10^" + to_string(digit); if(!isPositive) ret = "-" + ret; return ret;&#125;int main()&#123; int N; string A,B; string Ac,Bc; cin &gt;&gt; N &gt;&gt; A &gt;&gt; B; Ac = chop(A,N); Bc = chop(B,N); if(Ac==Bc) &#123; cout &lt;&lt; "YES " &lt;&lt; Ac; &#125; else &#123; cout &lt;&lt; "NO " &lt;&lt; Ac &lt;&lt; " " &lt;&lt; Bc; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1052解题报告]]></title>
    <url>%2Fpost%2FPAT_1052%2F</url>
    <content type="text"><![CDATA[1052 Linked List Sorting题目1052 Linked List Sorting （25 分）A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification:Each input file contains one test case. For each case, the first line contains a positive N (&lt;10^5 ) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the address of the node in memory, Key is an integer in [−10^​5​​,10^​5​ ], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification:For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input:5 0000111111 100 -100001 0 2222233333 100000 1111112345 -1 3333322222 1000 12345Sample Output:5 1234512345 -1 0000100001 0 1111111111 100 2222222222 1000 3333333333 100000 -1 思路一开始没考虑到链表中还有无效的数据，直接把所有节点排序，然后有几个case过不了。先从头开始，沿着next的顺序读一遍，存到数组里，然后排个序再输出就好。更小空间复杂度的方法是在Node加一个flag判断是否读取，在排序的时候把无效的节点排到最后，再输出前面有效的n个节点即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Node&#123; int address,key,next; friend bool operator&lt;(Node n1,Node n2)&#123; return n1.key&lt;n2.key; &#125;&#125;;vector&lt;Node&gt; vN;Node aN[100000];int main()&#123; ios::sync_with_stdio(false); int N,st; cin &gt;&gt; N &gt;&gt; st; int address,key,next; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; address &gt;&gt; key &gt;&gt; next; aN[address] = Node&#123;address,key,next&#125;; &#125; while(st!=-1)&#123; vN.push_back(aN[st]); st = aN[st].next; &#125; sort(vN.begin(),vN.end()); cout &lt;&lt; vN.size() &lt;&lt; " "; if(vN.size()&gt;0)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[0].address &lt;&lt; "\n"; &#125; else&#123; cout &lt;&lt; "-1"; return 0; &#125; for(int i=0;i&lt;vN.size();i++)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[i].address &lt;&lt; " " &lt;&lt; vN[i].key &lt;&lt; " "; if(i!=vN.size()-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[i+1].address; &#125; else cout &lt;&lt; "-1"; cout &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1045解题报告]]></title>
    <url>%2Fpost%2FPAT-1045%2F</url>
    <content type="text"><![CDATA[1045 Favorite Color Stripe题目1045 Favorite Color Stripe （30 分）Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (≤200) followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (≤10^4) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line a separated by a space. Output Specification:For each test case, simply print in a line the maximum length of Eva’s favorite stripe. Sample Input:65 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6Sample Output:7 思路算是我做的第二道动态规划题目，想明白了之后还是很简单的，我都不敢相信这么简单。题目类似最长公共子序列，但是序列a中的元素允许再序列b中重复多次。记dp[i][j]为a[1]~a[i]与b[1]~b[j]的最长可重复公共子序列，那么有状态转移方程：如果a[i] = b[j], dp[i][j] = dp[i][j-1] +1，因为a[i]可能在b[j]前出现过，所以i不用变如果a[i] != b[j], dp[i][j] = max(dp[i-1][j],dp[i][j-1])边界条件即dp[i][0] = 0,dp[j][0] = 0，这个条件在初始化dp的时候已经实现了。 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int a[201];int b[10001];int dp[201][10001];int main()&#123; int N,L,M; cin &gt;&gt; N; cin &gt;&gt; M; for(int i=1;i&lt;=M;i++) cin &gt;&gt; a[i]; cin &gt;&gt; L; for(int i=1;i&lt;=L;i++) cin &gt;&gt; b[i]; int maxLen = 0; for(int i=1;i&lt;=M;i++)&#123; for(int j=1;j&lt;=L;j++)&#123; if(a[i]==b[j]) dp[i][j] = dp[i][j-1]+1; else dp[i][j] = max(dp[i][j-1],dp[i-1][j]); if(dp[i][j]&gt;maxLen) maxLen = dp[i][j]; &#125; &#125; cout &lt;&lt; maxLen; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1044解题报告]]></title>
    <url>%2Fpost%2FPAT-1044%2F</url>
    <content type="text"><![CDATA[1044 Shopping in Mars题目1044 Shopping in Mars （25 分）Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15).Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤10^​5​​ ), the total number of diamonds on the chain, and M (≤10^8​​ ), the amount that the customer has to pay. Then the next line contains N positive numbers D1​​ ⋯D​N​​ (D​i​​ ≤10^​3 for all i=1,⋯,N) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification:For each test case, print i-j in a line for each pair of i ≤ j such that Di + … + Dj = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i. If there is no solution, output i-j for pairs of i ≤ j such that Di + … + Dj &gt;M with (Di + … + Dj −M) minimized. Again all the solutions must be printed in increasing order of i. It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1:16 153 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13Sample Output 1:1-54-67-811-11Sample Input 2:5 132 4 5 7 9Sample Output 2:2-44-5 思路将前i个数的和保存在sum数组中，然后从i到j的和就是sum[j]-sum[i]。一开始直接两重循环来做，O(n^2)的复杂度，果然两个case超时了。改用二分查找就通过了。注意二分查找的写法，在找不到时返回大于查找值的第一个位置。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int dc[100010];long long sum[100010];int N,M;int Half(int i)&#123; int left = i; int right = N; int mid; while(left&lt;right)&#123;// cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; " right: " &lt;&lt;right &lt;&lt; endl; mid = (left+right)/2; if(sum[mid]-sum[i-1]&lt;M) left = mid+1; else if(sum[mid]-sum[i-1]&gt;M) right = mid; else return mid; &#125; return left;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M; for(int i=0;i&lt;N;i++) cin &gt;&gt; dc[i]; sum[0] = 0; for(int i=1;i&lt;=N;i++) sum[i] = sum[i-1] + dc[i-1];// for(int i=0;i&lt;=N;i++) cout &lt;&lt; sum[i] &lt;&lt;" ";// cout &lt;&lt; endl; vector&lt;int&gt; v; long long minMoney = 0x3fffffff; for(int i=1;i&lt;=N;i++)&#123; int tmp = Half(i);// cout &lt;&lt; "Half" &lt;&lt; i &lt;&lt; " " &lt;&lt; tmp &lt;&lt; endl; if(sum[tmp] - sum[i-1] &lt; M) continue; if(sum[tmp]-sum[i-1] &lt; minMoney)&#123; minMoney = sum[tmp]-sum[i-1];// cout &lt;&lt; "minMoney: " &lt;&lt; minMoney &lt;&lt; endl; v.clear(); v.push_back(i); v.push_back(tmp); &#125; else if(sum[tmp] - sum[i-1] == minMoney)&#123; v.push_back(i); v.push_back(tmp); &#125; &#125;// cout &lt;&lt; minMoney &lt;&lt; endl; for(int i=0;i&lt;v.size()/2;i++)&#123; cout &lt;&lt; v[2*i] &lt;&lt; "-" &lt;&lt; v[2*i+1] &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1043解题报告]]></title>
    <url>%2Fpost%2FPAT-1043%2F</url>
    <content type="text"><![CDATA[1043 Is It a Binary Search Tree题目1043 Is It a Binary Search Tree （25 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST. Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:78 6 5 7 10 8 11Sample Output 1:YES5 7 6 8 11 10 8Sample Input 2:78 10 11 8 6 7 5Sample Output 2:YES11 8 10 7 5 6 8Sample Input 3:78 6 8 5 10 9 11Sample Output 3:NO 思路一开始又SB的以为preOrder是左中右的访问顺序，结果题目都读不懂。读懂题目之后，就假设是序列是BST，然后来递归的建立这棵树。首先以BST（非镜像），以8 6 5 7 10 8 11为例，首先由于是先序遍历，8就是根，左子树就是右边序列6 5 7 10 8 11中小于根的部分，右子树就是大于等于根的序列。用i从左到右的扫描，到大于等于根的地方停下，j从又往左扫描到小于根的地方停下。如果i+1=j，那么符合BST的条件，继续递归的生成左子树和右子树，否则不满足BST的条件，所有递归都中止。一开始在扫描的时候没有判断扫描的终点，导致一不小心就扫描出了[from,to]的范围，甚至出现段错误。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;typedef struct Node *Tree;struct Node&#123; int value; Tree left,right;&#125;;int seq[1010];int N;bool isBST = true;bool first = true;Tree buildTree(int from,int to)&#123; if(!isBST) return NULL; if(from &gt; to) return NULL; if(from==to) return new Node&#123;seq[from],NULL,NULL&#125;; int i=from,j=to+1; while(seq[i+1]&lt;seq[from]&amp;&amp;i&lt;=to-1) i++; while(seq[j-1]&gt;=seq[from]&amp;&amp;j&gt;=from+2) j--; if(i+1==j)&#123; return new Node&#123;seq[from],buildTree(from+1,i),buildTree(j,to)&#125;; &#125; else&#123; isBST = false; return NULL; &#125;&#125;Tree buildTreeM(int from,int to)&#123; if(!isBST) return NULL; if(from &gt; to) return NULL; if(from==to) return new Node&#123;seq[from],NULL,NULL&#125;; int i=from,j=to+1; while(seq[i+1]&gt;=seq[from]&amp;&amp;i&lt;=to-1) i++; while(seq[j-1]&lt;seq[from]&amp;&amp;j&gt;=from+2) j--; if(i+1==j)&#123; return new Node&#123;seq[from],buildTreeM(from+1,i),buildTreeM(j,to)&#125;; &#125; else&#123; isBST = false; return NULL; &#125;&#125;void postOrder(Tree t)&#123; if(t-&gt;left) postOrder(t-&gt;left); if(t-&gt;right) postOrder(t-&gt;right); if(first) first = false; else cout &lt;&lt;" "; cout &lt;&lt; t-&gt;value;&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; seq[i]; &#125; if(N==0)&#123; cout &lt;&lt; "YES\n"; return 0; &#125; Tree t = buildTree(0,N-1); if(isBST)&#123; cout &lt;&lt; "YES\n"; postOrder(t); &#125; else &#123; isBST = true; t = buildTreeM(0,N-1); if(isBST)&#123; cout &lt;&lt; "YES\n"; postOrder(t); &#125; else&#123; cout &lt;&lt; "NO\n"; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1040解题报告]]></title>
    <url>%2Fpost%2FPAT-1040%2F</url>
    <content type="text"><![CDATA[1040 Longest Symmetric String题目1040 Longest Symmetric String （25 分）Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11. Input Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification:For each test case, simply print the maximum length in a line. Sample Input:Is PAT&amp;TAP symmetric?Sample Output:11 思路第一次做动态规划的题目……参照《算法笔记》中动态规划的内容。bool dp[i]j用来记录从i到j的子串是否为回文字符串。状态转移方程也很简单：dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == s[j]。问题是如何从边界出发计算整个数组，采用的方法是先初始化长度为1和2的子串，然后从3开始计算，一直计算完整个字符串。字符串长度为1的时候，初始化长度为2的字串会读取到’\0’因而不会产生错误。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;bool dp[1010][1010];int main()&#123; int maxLen = 1; char s[1010]; cin.getline(s,1010); int len = 0; while(s[len++]!='\0'); for(int i=0;i&lt;len;i++)&#123; dp[i][i] = true; &#125; for(int i=0;i&lt;len-1;i++)&#123; if(s[i]==s[i+1])&#123; dp[i][i+1] = true; maxLen = 2; &#125; &#125; for(int L = 3;L&lt;=len;L++)&#123; for(int i=0;i&lt;len-L+1;i++)&#123; if(dp[i+1][i+L-2]==true&amp;&amp;s[i]==s[i+L-1])&#123; dp[i][i+L-1] = true; maxLen = L; &#125; &#125; &#125; cout &lt;&lt; maxLen; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1039解题报告]]></title>
    <url>%2Fpost%2FPAT_1039%2F</url>
    <content type="text"><![CDATA[1039 Course List for Student题目1039 Course List for Student （25 分）Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤40,000), the number of students who look for their course lists, and K (≤2,500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students N_i​​(≤200) are given in a line. Then in the next line, N_​i student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification:For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student’s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input:11 54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE11 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB55 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9Sample Output:ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5NON9 0 思路好简单的题目，map&lt;string,vector&lt;int&gt; &gt;就好。发现最后一个点超时了没过，考虑到数据量比较大，把输入输出优化ios::sync_with_stdio(false)加上就刚好过了~看了一下其他人的做法，因为名字都很有规律，可以直接转换成int型存在数组里，效率肯定比map要高不少。 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;map&lt;string,vector&lt;int&gt; &gt; m;int main()&#123; ios::sync_with_stdio(false); int N,K; cin &gt;&gt; N &gt;&gt; K; int index,num; string name; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; index &gt;&gt; num; for(int i=0;i&lt;num;i++)&#123; cin &gt;&gt; name; m[name].push_back(index); &#125; &#125; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; name; sort(m[name].begin(),m[name].end()); cout &lt;&lt; name &lt;&lt; " "; cout &lt;&lt; m[name].size(); for(int j=0;j&lt;m[name].size();j++)&#123; cout &lt;&lt; " " &lt;&lt; m[name][j]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125; 不使用map的版本，最后一个case的用时比上面的版本降低了一半，但是其他case的用时都增加了一倍左右好奇怪。更诡异的是str2int函数改为引用传参的方式case的用时也会增加…… 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; v[200000];int str2int(string &amp;s)&#123; return (s[0]-'A')*26*26*10+(s[1]-'A')*26*10+(s[2]-'A')*10+s[3]-'0';&#125;int main()&#123; ios::sync_with_stdio(false); int N,K; cin &gt;&gt; N &gt;&gt; K; int index,num; string name; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; index &gt;&gt; num; for(int i=0;i&lt;num;i++)&#123; cin &gt;&gt; name; v[str2int(name)].push_back(index); &#125; &#125; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; name; sort(v[str2int(name)].begin(),v[str2int(name)].end()); cout &lt;&lt; name &lt;&lt; " "; cout &lt;&lt; v[str2int(name)].size(); for(int j=0;j&lt;v[str2int(name)].size();j++)&#123; cout &lt;&lt; " " &lt;&lt; v[str2int(name)][j]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1017解题报告]]></title>
    <url>%2Fpost%2FPAT_1017%2F</url>
    <content type="text"><![CDATA[1017 Queueing at Bank题目1017 Queueing at Bank （25 分）Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour. Now given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤10^4) - the total number of customers, and K (≤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time. Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average. Output Specification:For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place. Sample Input:7 307:55:00 1617:00:01 207:59:59 1508:01:00 6008:00:00 3008:00:02 208:03:00 10Sample Output:8.2 思路思路参照陈越姥姥的《数据结构》8.1银行排队问题，细节有点多，很容易写错。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int N,K;int crtTime;int totalTime = 0;int cusNum;struct Customer&#123; int arrive,process; friend bool operator&lt; (Customer c1,Customer c2)&#123; return c1.arrive&gt;c2.arrive; &#125;&#125;;priority_queue&lt;Customer&gt; waitingLine;vector&lt;int&gt; windowsTime;int time(int hh,int mm,int ss)&#123; return hh*3600+mm*60+ss;&#125;int findNextWindows()&#123; int nextWin; int minTime = 999999; for(int i=0;i&lt;K;i++)&#123; if(windowsTime[i]&lt;minTime)&#123; minTime = windowsTime[i]; nextWin = i; &#125; &#125; for(int i=0;i&lt;K;i++) windowsTime[i]-=minTime; crtTime+=minTime; return nextWin;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K; windowsTime.resize(K); fill(windowsTime.begin(),windowsTime.end(),0); int hh,mm,ss,process; char c; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; hh &gt;&gt; c; cin &gt;&gt; mm &gt;&gt; c; cin &gt;&gt; ss &gt;&gt; process; if(time(hh,mm,ss)&lt;=time(17,0,0)) waitingLine.push(Customer&#123;time(hh,mm,ss),process*60&#125;); &#125; cusNum = waitingLine.size(); crtTime = time(8,0,0); while(!waitingLine.empty())&#123; Customer cus = waitingLine.top(); waitingLine.pop(); int nextWin = findNextWindows(); if(cus.arrive&lt;=crtTime)&#123; totalTime+= crtTime-cus.arrive;// cout &lt;&lt; "wait time: " &lt;&lt; crtTime-cus.arrive &lt;&lt; endl; &#125; else&#123; for(int i=0;i&lt;K;i++)&#123; windowsTime[i] = max(windowsTime[i]-(cus.arrive-crtTime),0); &#125; crtTime = cus.arrive; &#125; windowsTime[nextWin] = cus.process; &#125; cout.setf(ios::fixed); cout.precision(1); cout &lt;&lt; double(totalTime)/cusNum/60&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1100,1101,1102,1103解题报告]]></title>
    <url>%2Fpost%2FPAT_1100_1101_1102_1103%2F</url>
    <content type="text"><![CDATA[1100 Mars Numbers题目1100 Mars Numbers （20 分）People on Mars count their numbers with base 13: Zero on Earth is called “tret” on Mars.The numbers 1 to 12 on Earch is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.For the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.For examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars. Output Specification:For each number, print in a line the corresponding number in the other language. Sample Input:4295elo novtamSample Output:hel marmay11513 思路送分题，注意输入输出格式。除非数字本身是零，否则不输出某位上的零。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;map&lt;string,int&gt; str2num = &#123;&#123;"tret",0&#125;,&#123;"jan",1&#125;,&#123;"feb",2&#125;,&#123;"mar",3&#125;,&#123;"apr",4&#125;, &#123;"may",5&#125;,&#123;"jun",6&#125;,&#123;"jly",7&#125;, &#123;"aug",8&#125;,&#123;"sep",9&#125;,&#123;"oct",10&#125;,&#123;"nov",11&#125;,&#123;"dec",12&#125;,&#123;"tam",1*13&#125;,&#123;"hel",2*13&#125;,&#123;"maa",3*13&#125;,&#123;"huh",4*13&#125;, &#123;"tou",5*13&#125;,&#123;"kes",6*13&#125;,&#123;"hei",7*13&#125;, &#123;"elo",8*13&#125;,&#123;"syy",9*13&#125;,&#123;"lok",10*13&#125;,&#123;"mer",11*13&#125;,&#123;"jou",12*13&#125;&#125;;string num2str1[] = &#123;"tret","jan","feb","mar","apr","may","jun","jly","aug","sep","oct","nov","dec"&#125;;string num2str2[] = &#123;"tret","tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mer","jou"&#125;;void ToMars(string s)&#123; int num=0; for(int i=0;i&lt;s.size();i++) num = num*10+ s[i]-'0'; if(num==0)&#123; cout &lt;&lt; num2str1[0] &lt;&lt; "\n"; return; &#125; if(num/13!=0) cout &lt;&lt; num2str2[num/13]; if(num%13!=0)&#123; if(num/13!=0) cout &lt;&lt; " "; cout &lt;&lt; num2str1[num%13]; &#125; cout &lt;&lt; "\n";&#125;void ToEarth(string s1,string s2)&#123; if(s2=="")&#123; cout &lt;&lt; str2num[s1] &lt;&lt; "\n"; &#125; else&#123; cout &lt;&lt; str2num[s2] + str2num[s1] &lt;&lt; "\n"; &#125;&#125;int main()&#123; int N; cin &gt;&gt; N; string s1,s2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; s1; s2 = ""; if(cin.get()!='\n') cin &gt;&gt; s2; if(s2==""&amp;&amp;isdigit(s1[0])) ToMars(s1); else ToEarth(s1,s2); &#125; return 0;&#125; 1101 Quick Sort题目There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;and for the similar reason, 4 and 5 could also be the pivot.Hence in total there are 3 pivot candidates. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10​5​​ ). Then the next line contains N distinct positive integers no larger than 10​9​​ . The numbers in a line are separated by spaces. Output Specification:For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:51 3 2 4 5Sample Output:31 4 5 思路没什么思路，先想着枚举法试一下，果然好几个点过不了。然后看了一下网上的做法，原来这么简单……思想就是如果某个位置的数字比左边的最大值还要大，并且比右边的最小值还要小，那么这个数就是pivot。那就先从左向右扫描一次，求出maxL[i]，即下标从0到i位置上最大的数；同理从右向左扫描一次，求出minR[i]。如果maxL[i]==minR[i]的话那这个数就可以作为pivot。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int num[100010];int maxL[100010];int minR[100010];vector&lt;int&gt; v;int main()&#123; ios::sync_with_stdio(false); int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; num[i]; int max = num[0]; for(int i=0;i&lt;N;i++)&#123; if(num[i]&gt;max) max = num[i]; maxL[i] = max; &#125; int min = num[N-1]; for(int i=N-1;i&gt;=0;i--)&#123; if(num[i]&lt;min) min = num[i]; minR[i] = min; &#125; for(int i=0;i&lt;N;i++)&#123; if(num[i]==maxL[i] &amp;&amp; num[i] == minR[i]) v.push_back(num[i]); &#125; sort(v.begin(),v.end()); int len = v.size(); cout &lt;&lt; len &lt;&lt; "\n"; for(int i=0;i&lt;len;i++)&#123; if(i!=0) cout &lt;&lt; " "; cout &lt;&lt; v[i]; &#125; cout &lt;&lt; "\n"; return 0;&#125; 1102 Invert a Binary Tree题目1102 Invert a Binary Tree （25 分）The following is from Max Howell @twitter: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.Now it’s your turn to prove that YOU CAN invert a binary tree! Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node from 0 to N−1, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification:For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:81 -- -0 -2 7- -- -5 -4 6Sample Output:3 7 2 6 4 0 5 16 5 7 4 3 2 0 1 思路听过这个故事的，反转二叉树感觉真的不难呀- -不过其实这道题目并不用反转，只要遍历的时候，把正常的先左节点后右节点的顺序反过来就好。还有需要注意的就是树的根节点并不是从0开始，所以要先找一下根节点。水题一道。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int nLeft[10];int nRight[10];bool isChild[10];queue&lt;int&gt; Q;int root;bool first=true;void inOrder(int n)&#123; if(nRight[n]!=-1) inOrder(nRight[n]); if(first) first = false; else cout &lt;&lt; " "; cout &lt;&lt; n; if(nLeft[n]!=-1) inOrder(nLeft[n]);&#125;int main()&#123; int N; cin &gt;&gt; N; char c1,c2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; c1 &gt;&gt; c2; nLeft[i] = c1=='-'?-1:(c1-'0'); nRight[i] = c2=='-'?-1:(c2-'0'); &#125; //find root for(int i=0;i&lt;N;i++)&#123; if(nLeft[i]!=-1) isChild[nLeft[i]] = true; if(nRight[i]!=-1) isChild[nRight[i]] = true; &#125; for(int i=0;i&lt;N;i++) &#123; if(!isChild[i]) root = i; &#125; //level order Q.push(root); while(!Q.empty())&#123; int tmp = Q.front(); if(tmp!=root) cout &lt;&lt; " "; cout &lt;&lt; tmp; Q.pop(); if(nRight[tmp]!=-1) Q.push(nRight[tmp]); if(nLeft[tmp]!=-1) Q.push(nLeft[tmp]); &#125; cout &lt;&lt; "\n"; //in-order travelsal inOrder(root); return 0;&#125; 1103 Integer Factorization题目 思路想了半天，感觉是DFS，但是还是无从下手……参考了柳神的代码，但是该代码在我电脑上运行有问题，double的pow强制类型转换成int之后会产生误差。好了说一下思路，这就是一个DFS+剪枝的问题，首先初始化一个powP数组以避免重复进行次方运算。然后用tmpSeq来临时记录当前的“路径”。然后开始dfs：递归终止的条件是因数的数量达到了K，然后判断一下当前的k个数是否满足题目的条件，如果满足并且facSum更大，就记录下来。如果没有达到k个数，就继续往下递归。往下递归需要注意：1.下一个数的上界的选取，第一个数就取sqrt(N)，后面的数的上界是前一个数（由于对称性，只需要考虑降序排列的情况，否则计算量将急剧增加）。2.当sum+powP[i]&lt;=N时才向下递归 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int N,K,P;int powP[30];vector&lt;int&gt; bestSqe;vector&lt;int&gt; tmpSqe;int maxFacSum =-1;int bound;void powInit()&#123; powP[0] = 0;powP[1] = 1; int sum=1,i=2,p; while(sum&lt;=N) &#123; sum = 1; p = P; while(p--) sum*=i; powP[i] = sum; i++; &#125; bound = i-1;&#125;//k：第k个数//sum：前k个因数的P次方的和//facSum：前k个因数的和void dfs(int k,int sum,int facSum)&#123;// cout &lt;&lt; k &lt;&lt;" " &lt;&lt;sum &lt;&lt; " " &lt;&lt; facSum &lt;&lt; endl; if(k==K)&#123; if(sum == N&amp;&amp;facSum&gt;maxFacSum)&#123; bestSqe = tmpSqe; maxFacSum = facSum; &#125; return; &#125; //确保序列是递减的 int upBound = k==0?bound:tmpSqe[k-1]; for(int i = upBound;i&gt;=1;i--)&#123; if(sum+powP[i]&lt;=N)&#123; tmpSqe[k] = i; dfs(k+1,sum+powP[i],facSum+i); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; P; powInit(); tmpSqe.resize(K); dfs(0,0,0); if(maxFacSum==-1)&#123; cout &lt;&lt; "Impossible\n"; return 0; &#125; cout &lt;&lt; N &lt;&lt; " = "; for(int i=0;i&lt;bestSqe.size();i++)&#123; if(i!=0) cout &lt;&lt; " + "; cout &lt;&lt; bestSqe[i]&lt;&lt; "^" &lt;&lt; P; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1096,1097,1098,1099解题报告]]></title>
    <url>%2Fpost%2FPAT_1096_1097_1098_1099%2F</url>
    <content type="text"><![CDATA[1096 Consecutive Factors题目1096 Consecutive Factors （20 分） Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification:Each input file contains one test case, which gives the integer N (1&lt;N&lt;2^​31​). Output Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]factor[2]…*factor[k], where the factors are listed in increasing order, and 1 is NOT included. Sample Input:630Sample Output:3567 思路题目的意思是让找到一个整数最长的连续的因数（不是质因数）。一开始完全没头绪的题目，一开始想先分解成质因数，但是因数的组合也很麻烦……那就不妨暴力求解一下~虽然知道因子的上界是sqrt(N),但一开始偷懒先写的是N/2，果然有一个测试点过不了。然后想想，2^31数量级的情况下，sqrt(N)和N/2差了好多好多。改成sqrt(N)就果断过了。注意要用&lt;=,否则N=4的时候会出错。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt; factors;int main()&#123; int N; cin &gt;&gt; N; int maxNum = 1; factors.push_back(N); int sq = sqrt(N); //num个连续因子 for(int num = 1;num&lt;13;num++)&#123; //连续因子从start开始 bool end = false; for(int start = 2;start&lt;=sq;start++)&#123; //计算是否存在合适的连续因子 int product = 1; for(int i=start;i&lt;start+num;i++) product*=i; if(product&gt;N)&#123; end = true; break; &#125;else if(N%product==0)&#123; factors.clear(); for(int i = start;i&lt;start+num;i++) &#123; factors.push_back(i); &#125; maxNum = num; break; &#125; &#125; if(end) break; &#125; cout &lt;&lt; maxNum &lt;&lt; "\n"; for(int i=0;i&lt;factors.size();i++)&#123; if(i!=0) cout &lt;&lt;"*"; cout &lt;&lt; factors[i]; &#125; return 0;&#125; 1097 Deduplication on a Linked List题目1097 Deduplication on a Linked List （25 分）Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤10^5​​ ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the position of the node, Key is an integer of which absolute value is no more than 10^4​, and Next is the position of the next node. Output Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:00100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854Sample Output:00100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 思路删除一个链表中绝对值相同的节点，只保留第一个。简单的链表删除，删除之后把删掉的节点记录在lastDelete中，然后删除下一个节点的时候，把lastdelete指向这个被删除的节点。最后把lastDelete指向-1。一开始输出的时候忘了把next也要填充到5位，而示例的输入输出又刚好next都是五位的……在这个坑爹的问题上卡了好久。为什么PAT的输入输出总是这么的让我崩溃。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Node&#123; int value; int next;&#125;;Node List[100010];set&lt;int&gt; s;int lastDelete = -1;int firstDelete = -1;void output(int root)&#123; int temp = root; while(temp!=-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; temp &lt;&lt; " " &lt;&lt; List[temp].value &lt;&lt; " " ; if(List[temp].next!=-1)&#123; cout.width(5); cout.fill('0'); &#125; cout &lt;&lt; List[temp].next &lt;&lt; "\n"; temp = List[temp].next; &#125;&#125;int main()&#123; int N,start; cin &gt;&gt; start &gt;&gt; N; int pos; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; pos; cin &gt;&gt; List[pos].value; cin &gt;&gt; List[pos].next; &#125; int pre = start; s.insert(abs(List[start].value)); while(List[pre].next!=-1)&#123; int now = List[pre].next; //无需删除，继续查找 if(s.count(abs(List[now].value))==0) &#123; s.insert(abs(List[now].value)); pre = now; &#125;else&#123;//删除节点// cout &lt;&lt; "delete: " &lt;&lt;now &lt;&lt; endl; List[pre].next = List[now].next; if(lastDelete==-1) &#123; firstDelete = now; &#125; else&#123; List[lastDelete].next = now; &#125; lastDelete = now; &#125; &#125; List[lastDelete].next = -1; output(start); output(firstDelete); return 0;&#125; 1098 Insertion or Heap Sort题目1098 Insertion or Heap Sort （25 分）According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification:For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0Sample Output 1:Insertion Sort1 2 3 5 7 8 9 4 6 0Sample Input 2:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9Sample Output 2:Heap Sort5 4 3 1 0 2 6 7 8 9 思路给出一个序列，及排序到一半的序列，判断到底是插入排序还是堆排序，然后再进行下一步。主要考察对插入排序及堆排序的熟悉程度。因为插入排序比较好写，所以就先一步一步的执行插入排序，和给定的序列进行比较，相同说明是插入排序，如果排序完成还不同说明是堆排序。判断出堆排序后，因为堆排序pop的每一个数都是堆中的最大值，所以堆排序序列后面的都是最大值，和之前插入排序已经排好的队列进行比较，就能找到排序进行到哪一步了，再进行一步排序就好。为了方便插入排序的比较和堆排序的下标运算，数组存放从1开始，0的值设为-1坐标标兵。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;int ori[110] = &#123;-1&#125;;int ins[110] = &#123;-1&#125;;int sorted[110] = &#123;-1&#125;;int N;//将第n个元素插入到前n-1个元素中合适的位置void Insertion(int arr[],int n)&#123; for(int i = n-1;i&gt;=0;i--)&#123; if(arr[n]&gt;arr[i])&#123; int temp = arr[n]; for(int j=n;j&gt;i+1;j--)&#123; arr[j] = arr[j-1]; &#125; arr[i+1] = temp; break; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N; for(int i=1;i&lt;=N;i++) &#123;cin &gt;&gt;ori[i];ins[i] = ori[i];&#125; for(int i=1;i&lt;=N;i++) cin &gt;&gt; sorted[i]; bool same; for(int j=2;j&lt;=N;j++)&#123; same = true; Insertion(ins,j);// for(int i=1;i&lt;=N;i++) cout &lt;&lt; ins[i] &lt;&lt; " ";// cout &lt;&lt; endl; for(int i=1;i&lt;=N;i++)&#123; if(ins[i]!=sorted[i])&#123; same = false; break; &#125; &#125; if(same)&#123; cout &lt;&lt; "Insertion Sort\n"; Insertion(ins,j+1); for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; ins[i]; &#125; return 0; &#125; &#125; int flag = N; for(;flag&gt;=1;flag--)&#123; if(sorted[flag]!=ins[flag]) break; &#125; int tem = sorted[flag]; sorted[flag] = sorted[1]; int prt = 1; while(prt*2&lt;flag)&#123; int chd = (prt*2+1==flag||sorted[prt*2]&gt;sorted[prt*2+1])?prt*2:prt*2+1; if(tem&gt;=sorted[chd]) break; sorted[prt] = sorted[chd];// cout &lt;&lt; prt &lt;&lt; " " &lt;&lt; chd &lt;&lt; endl; prt = chd; &#125; sorted[prt] = tem; cout &lt;&lt; "Heap Sort\n"; for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; sorted[i]; &#125; return 0;&#125; 1099 Build A Binary Search Tree题目1099 Build A Binary Search Tree （30 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input:91 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42Sample Output:58 25 82 11 38 67 45 73 42 思路考察二叉树的操作。先用递归把各个节点的左右子树的数量算出来，再用递归把排序后的数字填入节点中。再用个队列层序遍历整棵树并输出。看了一下别人的答案发现，二叉搜索树的中序遍历原来就是按数值从小到大遍历一遍，那直接中序遍历填数值，层序遍历输出就好。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;struct Node&#123; int value; int left,right; int leftNum,rightNum;&#125;;Node Tree[110];int N;vector&lt;int&gt; v;int CalChildrenNum(int root)&#123; Tree[root].leftNum = Tree[root].left==-1?0:(CalChildrenNum(Tree[root].left)+1); Tree[root].rightNum = Tree[root].right==-1?0:(CalChildrenNum(Tree[root].right)+1);// cout &lt;&lt; "Children Number of " &lt;&lt; root &lt;&lt; " is" &lt;&lt; Tree[root].leftNum+Tree[root].rightNum &lt;&lt; endl; return Tree[root].leftNum+Tree[root].rightNum;&#125;void build(int root,int from)&#123; Tree[root].value = v[from + Tree[root].leftNum];// cout &lt;&lt; "root: " &lt;&lt; root &lt;&lt; " value:" &lt;&lt; Tree[root].value &lt;&lt; endl; if(Tree[root].left!=-1) build(Tree[root].left,from); if(Tree[root].right!=-1) build(Tree[root].right,from + Tree[root].leftNum+1);&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; Tree[i].left &gt;&gt; Tree[i].right; &#125; int tem; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; tem; v.push_back(tem); &#125; sort(v.begin(),v.end()); CalChildrenNum(0); build(0,0); queue&lt;int&gt; q; q.push(0); while(!q.empty())&#123; int p = q.front(); q.pop(); if(p!=0) cout &lt;&lt; " "; cout &lt;&lt; Tree[p].value; if(Tree[p].left!=-1) q.push(Tree[p].left); if(Tree[p].right!=-1) q.push(Tree[p].right); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fpost%2Ffirst_article%2F</url>
    <content type="text"><![CDATA[博客终于搭建完成了！经过千辛万苦（长达两天的努力），我的博客终于上线了！以后会在这里记录一些科研以及学习的心得。 让我先试着放张图片： 下面放一段代码12str = "Hello world!"print(str) 下面是一个表格 AND true false true true false false false false 1.hexo从零开始到搭建完整2.Hexo下的Markdown语法(GFM)写博客3.Hexo搭建的GitHub博客之优化大全4.Hexo 官网5.Next 使用文档]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
