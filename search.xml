<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT 1096,1097,1098,1099解题报告]]></title>
    <url>%2Fpost%2FPAT_1096_1097_1098_1099%2F</url>
    <content type="text"><![CDATA[1096 Consecutive Factors题目1096 Consecutive Factors （20 分） Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification:Each input file contains one test case, which gives the integer N (1&lt;N&lt;2^​31​). Output Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]factor[2]…*factor[k], where the factors are listed in increasing order, and 1 is NOT included. Sample Input:630Sample Output:3567 思路题目的意思是让找到一个整数最长的连续的因数（不是质因数）。一开始完全没头绪的题目，一开始想先分解成质因数，但是因数的组合也很麻烦……那就不妨暴力求解一下~虽然知道因子的上界是sqrt(N),但一开始偷懒先写的是N/2，果然有一个测试点过不了。然后想想，2^31数量级的情况下，sqrt(N)和N/2差了好多好多。改成sqrt(N)就果断过了。注意要用&lt;=,否则N=4的时候会出错。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt; factors;int main()&#123; int N; cin &gt;&gt; N; int maxNum = 1; factors.push_back(N); int sq = sqrt(N); //num个连续因子 for(int num = 1;num&lt;13;num++)&#123; //连续因子从start开始 bool end = false; for(int start = 2;start&lt;=sq;start++)&#123; //计算是否存在合适的连续因子 int product = 1; for(int i=start;i&lt;start+num;i++) product*=i; if(product&gt;N)&#123; end = true; break; &#125;else if(N%product==0)&#123; factors.clear(); for(int i = start;i&lt;start+num;i++) &#123; factors.push_back(i); &#125; maxNum = num; break; &#125; &#125; if(end) break; &#125; cout &lt;&lt; maxNum &lt;&lt; "\n"; for(int i=0;i&lt;factors.size();i++)&#123; if(i!=0) cout &lt;&lt;"*"; cout &lt;&lt; factors[i]; &#125; return 0;&#125; 1097 Deduplication on a Linked List题目1097 Deduplication on a Linked List （25 分）Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤10^5​​ ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the position of the node, Key is an integer of which absolute value is no more than 10^4​, and Next is the position of the next node. Output Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:00100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854Sample Output:00100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 思路删除一个链表中绝对值相同的节点，只保留第一个。简单的链表删除，删除之后把删掉的节点记录在lastDelete中，然后删除下一个节点的时候，把lastdelete指向这个被删除的节点。最后把lastDelete指向-1。一开始输出的时候忘了把next也要填充到5位，而示例的输入输出又刚好next都是五位的……在这个坑爹的问题上卡了好久。为什么PAT的输入输出总是这么的让我崩溃。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Node&#123; int value; int next;&#125;;Node List[100010];set&lt;int&gt; s;int lastDelete = -1;int firstDelete = -1;void output(int root)&#123; int temp = root; while(temp!=-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; temp &lt;&lt; " " &lt;&lt; List[temp].value &lt;&lt; " " ; if(List[temp].next!=-1)&#123; cout.width(5); cout.fill('0'); &#125; cout &lt;&lt; List[temp].next &lt;&lt; "\n"; temp = List[temp].next; &#125;&#125;int main()&#123; int N,start; cin &gt;&gt; start &gt;&gt; N; int pos; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; pos; cin &gt;&gt; List[pos].value; cin &gt;&gt; List[pos].next; &#125; int pre = start; s.insert(abs(List[start].value)); while(List[pre].next!=-1)&#123; int now = List[pre].next; //无需删除，继续查找 if(s.count(abs(List[now].value))==0) &#123; s.insert(abs(List[now].value)); pre = now; &#125;else&#123;//删除节点// cout &lt;&lt; "delete: " &lt;&lt;now &lt;&lt; endl; List[pre].next = List[now].next; if(lastDelete==-1) &#123; firstDelete = now; &#125; else&#123; List[lastDelete].next = now; &#125; lastDelete = now; &#125; &#125; List[lastDelete].next = -1; output(start); output(firstDelete); return 0;&#125; 1098 Insertion or Heap Sort题目1098 Insertion or Heap Sort （25 分）According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification:For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0Sample Output 1:Insertion Sort1 2 3 5 7 8 9 4 6 0Sample Input 2:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9Sample Output 2:Heap Sort5 4 3 1 0 2 6 7 8 9 思路给出一个序列，及排序到一半的序列，判断到底是插入排序还是堆排序，然后再进行下一步。主要考察对插入排序及堆排序的熟悉程度。因为插入排序比较好写，所以就先一步一步的执行插入排序，和给定的序列进行比较，相同说明是插入排序，如果排序完成还不同说明是堆排序。判断出堆排序后，因为堆排序pop的每一个数都是堆中的最大值，所以堆排序序列后面的都是最大值，和之前插入排序已经排好的队列进行比较，就能找到排序进行到哪一步了，再进行一步排序就好。为了方便插入排序的比较和堆排序的下标运算，数组存放从1开始，0的值设为-1坐标标兵。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;int ori[110] = &#123;-1&#125;;int ins[110] = &#123;-1&#125;;int sorted[110] = &#123;-1&#125;;int N;//将第n个元素插入到前n-1个元素中合适的位置void Insertion(int arr[],int n)&#123; for(int i = n-1;i&gt;=0;i--)&#123; if(arr[n]&gt;arr[i])&#123; int temp = arr[n]; for(int j=n;j&gt;i+1;j--)&#123; arr[j] = arr[j-1]; &#125; arr[i+1] = temp; break; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N; for(int i=1;i&lt;=N;i++) &#123;cin &gt;&gt;ori[i];ins[i] = ori[i];&#125; for(int i=1;i&lt;=N;i++) cin &gt;&gt; sorted[i]; bool same; for(int j=2;j&lt;=N;j++)&#123; same = true; Insertion(ins,j);// for(int i=1;i&lt;=N;i++) cout &lt;&lt; ins[i] &lt;&lt; " ";// cout &lt;&lt; endl; for(int i=1;i&lt;=N;i++)&#123; if(ins[i]!=sorted[i])&#123; same = false; break; &#125; &#125; if(same)&#123; cout &lt;&lt; "Insertion Sort\n"; Insertion(ins,j+1); for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; ins[i]; &#125; return 0; &#125; &#125; int flag = N; for(;flag&gt;=1;flag--)&#123; if(sorted[flag]!=ins[flag]) break; &#125; int tem = sorted[flag]; sorted[flag] = sorted[1]; int prt = 1; while(prt*2&lt;flag)&#123; int chd = (prt*2+1==flag||sorted[prt*2]&gt;sorted[prt*2+1])?prt*2:prt*2+1; if(tem&gt;=sorted[chd]) break; sorted[prt] = sorted[chd];// cout &lt;&lt; prt &lt;&lt; " " &lt;&lt; chd &lt;&lt; endl; prt = chd; &#125; sorted[prt] = tem; cout &lt;&lt; "Heap Sort\n"; for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; sorted[i]; &#125; return 0;&#125; 1099 Build A Binary Search Tree题目1099 Build A Binary Search Tree （30 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input:91 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42Sample Output:58 25 82 11 38 67 45 73 42 思路考察二叉树的操作。先用递归把各个节点的左右子树的数量算出来，再用递归把排序后的数字填入节点中。再用个队列层序遍历整棵树并输出。看了一下别人的答案发现，二叉搜索树的中序遍历原来就是按数值从小到大遍历一遍，那直接中序遍历填数值，层序遍历输出就好。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;struct Node&#123; int value; int left,right; int leftNum,rightNum;&#125;;Node Tree[110];int N;vector&lt;int&gt; v;int CalChildrenNum(int root)&#123; Tree[root].leftNum = Tree[root].left==-1?0:(CalChildrenNum(Tree[root].left)+1); Tree[root].rightNum = Tree[root].right==-1?0:(CalChildrenNum(Tree[root].right)+1);// cout &lt;&lt; "Children Number of " &lt;&lt; root &lt;&lt; " is" &lt;&lt; Tree[root].leftNum+Tree[root].rightNum &lt;&lt; endl; return Tree[root].leftNum+Tree[root].rightNum;&#125;void build(int root,int from)&#123; Tree[root].value = v[from + Tree[root].leftNum];// cout &lt;&lt; "root: " &lt;&lt; root &lt;&lt; " value:" &lt;&lt; Tree[root].value &lt;&lt; endl; if(Tree[root].left!=-1) build(Tree[root].left,from); if(Tree[root].right!=-1) build(Tree[root].right,from + Tree[root].leftNum+1);&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; Tree[i].left &gt;&gt; Tree[i].right; &#125; int tem; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; tem; v.push_back(tem); &#125; sort(v.begin(),v.end()); CalChildrenNum(0); build(0,0); queue&lt;int&gt; q; q.push(0); while(!q.empty())&#123; int p = q.front(); q.pop(); if(p!=0) cout &lt;&lt; " "; cout &lt;&lt; Tree[p].value; if(Tree[p].left!=-1) q.push(Tree[p].left); if(Tree[p].right!=-1) q.push(Tree[p].right); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fpost%2Ffirst_article%2F</url>
    <content type="text"><![CDATA[博客终于搭建完成了！经过千辛万苦（长达两天的努力），我的博客终于上线了！以后会在这里记录一些科研以及学习的心得。 让我先试着放张图片： 下面放一段代码12str = "Hello world!"print(str) 下面是一个表格 AND true false true true false false false false 1.hexo从零开始到搭建完整2.Hexo下的Markdown语法(GFM)写博客3.Hexo搭建的GitHub博客之优化大全4.Hexo 官网5.Next 使用文档]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
