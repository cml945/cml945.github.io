<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT考试顺利通过]]></title>
    <url>%2Fpost%2FPAT_EXAM%2F</url>
    <content type="text"><![CDATA[一周没刷过题了，后天开题答辩还在做PPT，都不太想来考了，没想到竟然满分通过😋还好我来了。记录一下这个历史性的时刻。一开始第一道题就没做出来，看着数量级还挺大，用素数表的方式，发现建表的过程就耗时巨长，后面直接写个函数判断是否为素数，发现还是有问题，烦，跳过先做第二题。第二题一看就发现巨麻烦，写起来果然巨麻烦，花了一个小时，写了估计有一百行，发现只过了第一个case拿了15分，崩溃，仔细检查了一下，发现个小错误，多了1分，又发现个小错误，又多了2分，烦，接着跳。看了一下第二题的通过率巨低，只有百分之三四的样子。想到一个多小时过去了，只拿了十几分，凉凉。第三题，就是个简单的图的遍历，直接递归DFS做的，一次AC。第四题，树的DFS，输出到各个叶节点的路径，然后顺便判断一下是不是堆。也是超简单的题目，毫无压力的AC了。回到第一题，重新写。直接写个函数判断是否为素数，然后逐一判断就好，忘了输出前导0错了两个case，改一下就通过了。现在只剩下了巨复杂第二题，看了一下排名，九十六分排在五十几，前面基本都是满分的了。第二题通过的一共也就五十几个人，还剩一个小时，心里还是有点慌的。改了几个可能的输出格式的问题，发现没用。再一看，原来比较的函数由于结构体的字段太多漏比较了一项，赶紧改掉，提交，AC！看了一下排名，没错，100分，第一，那就没什么好说的了提前四十五分钟交卷走人~ PS.考完在外面冻了一个小时，然后说证书还有问题，然后又等了大半个小时，忍无可忍的走了……考完都不让拿个证书装个逼真是不爽。PS2.等真题放出来了再补充一下代码]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1104~1107解题报告]]></title>
    <url>%2Fpost%2FPAT_1104_1107%2F</url>
    <content type="text"><![CDATA[1104 Sum of Number Segments题目1104 Sum of Number Segments （20 分）Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4). Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than 10^​5​ . The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space. Output Specification:For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places. Sample Input:40.1 0.2 0.3 0.4Sample Output:5.00 思路先是暴力算了一下，果然最后两个点超时了，经过十几分钟的推导终于把第i个元素在长为n的所有子序列和中出现的次数(i+1)(n-i)给推导出来了。结果最后两个点竟然答案错误，检查了半天也没发现问题，用的是double也不可能溢出啊……上网查了一下别的代码，发现原来是(i+1)(n-i)会溢出……而我算的时候是先算的(i+1)(n-i)，然后再乘以该元素的值。所以把代码从Sum+= (i+1)*(N-i)*a[i]改成Sum+= a[i]*(i+1)*(N-i)就好了。 耗时：42min 代码123456789101112131415161718#include &lt;iostream&gt;using namespace std;double a[100000+10];int main()&#123; int N; scanf("%d",&amp;N); double Sum = 0; for(int i=0;i&lt;N;i++)&#123; scanf("%lf",&amp;a[i]); Sum+= a[i]*(i+1)*(N-i) ; &#125; printf("%.2f", Sum); return 0;&#125; 1105 Spiral Matrix题目1105 Spiral Matrix （25 分）This time your job is to fill a sequence of N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m rows and n columns, where m and n satisfy the following: m×n must be equal to N; m≥n; and m−n is the minimum of all the possible values. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N. Then the next line contains N positive integers to be filled into the spiral matrix. All the numbers are no more than 10^4. The numbers in a line are separated by spaces. Output Specification:For each test case, output the resulting matrix in m lines, each contains n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:1237 76 20 98 76 42 53 95 60 81 58 93Sample Output:98 95 9342 37 8153 20 7658 60 76 思路沿着螺旋的方式从大到小填充一个矩阵。设置四个状态，分别是向右、向下、向左和向上，一个方向填充到无法填充就切换到下一个状态。代码看起来有点冗余，但是写起来还是很快的。耗时：23min12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;int mar[10000][10000];int num[10000];int getn(int N)&#123; int sq = (int)sqrt(N*1.0); for(;sq&gt;0;sq--)&#123; if(N%sq==0) return sq; &#125; return 1;&#125;int main()&#123; int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; num[i]; sort(num,num+N); int n=getn(N); int m = N/n; int pos = N-1; int i = 0,j = 0; int state = 0; while(N&gt;0)&#123; mar[i][j] = num[pos--]; if(pos==-1) break; while(true)&#123; if(state%4==0)&#123; if(i+1&lt;n&amp;&amp;mar[i+1][j]==0) &#123; i++; break; &#125; else state++; &#125; else if(state%4==1)&#123; if(j+1&lt;m&amp;&amp;mar[i][j+1]==0) &#123; j++; break; &#125; else state++; &#125; else if(state%4==2)&#123; if(i-1&gt;=0&amp;&amp;mar[i-1][j]==0) &#123; i--; break; &#125; else state++; &#125; else if(state%4==3)&#123; if(j-1&gt;=0&amp;&amp;mar[i][j-1]==0) &#123; j--; break; &#125; else state++; &#125; &#125; &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(j!=0) cout &lt;&lt; " "; cout &lt;&lt; mar[j][i]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125; 1106 Lowest Price in Supply Chain题目1106 Lowest Price in Supply Chain （25 分）A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one’s supplier in a price P and sell or distribute them in a price that is r% higher than P. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers. Input Specification:Each input file contains one test case. For each case, The first line contains three positive numbers: N (≤10^5), the total number of the members in the supply chain (and hence their ID’s are numbered from 0 to N−1, and the root supplier’s ID is 0); P, the price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then N lines follow, each describes a distributor or retailer in the following format: $K_i$ ID[1] ID[2] … ID[$K_i$] where in the i-th line, Ki is the total number of distributors or retailers who receive products from supplier i, and is then followed by the ID’s of these distributors or retailers. $K_j$ being 0 means that the j-th member is a retailer. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceed 10​10​​ . Sample Input:10 1.80 1.003 2 3 51 91 41 702 6 11 8000Sample Output:1.8362 2 思路这道题和PAT-A-1079很相似，解法也很相似，就是树的遍历，这里为了方便直接用的DFS，然后对每个叶子节点判断一下价格就好。这里还可以通过当前价格是否已经超过最小的价格来做个剪枝。耗时：13min 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int N;double P,r;vector&lt;int&gt; Graph[100000];double minPrice = 1e11;int minNum;void DFS(int root,double price)&#123; if(Graph[root].size()==0)&#123; if(price &lt; minPrice)&#123; minPrice = price; minNum = 1; &#125; else if(price == minPrice) minNum++; return; &#125; for(int i=0;i&lt;Graph[root].size();i++) DFS(Graph[root][i],price*(1+r/100.));&#125;int main()&#123; cin &gt;&gt; N &gt;&gt;P &gt;&gt;r; int k,next; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; k; for(int j=0;j&lt;k;j++)&#123; cin &gt;&gt; next; Graph[i].push_back(next); &#125; &#125; DFS(0,P); printf("%.4f %d",minPrice,minNum); return 0;&#125; 1107 Social Clusters题目 思路简单的并查集，根节点用负数表示，其绝对值代表本集合的人数，合并的时候人数也要相加。排个序再输出就好。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int father[1010];void Union(int a,int b)&#123; while(father[a]&gt;0) a = father[a]; while(father[b]&gt;0) b = father[b]; if(a!=b) &#123; father[a] += father[b]; father[b] = a; &#125;&#125;vector&lt;int&gt; vec;int main()&#123; int N,K; int first; char c; int h; cin &gt;&gt;N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; K &gt;&gt; c; cin &gt;&gt; first; for(int j=1;j&lt;K;j++)&#123; cin &gt;&gt; h; Union(first,h); &#125; while(father[first]&gt;0) first = father[first]; father[first]--; &#125; for(int i=1;i&lt;=1000;i++) if(father[i]&lt;0) vec.push_back(father[i]); sort(vec.begin(),vec.end()); cout &lt;&lt; vec.size() &lt;&lt; "\n"; for(int i=0;i&lt;vec.size();i++) &#123; if(i!=0) cout &lt;&lt; " "; cout &lt;&lt; -vec[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1085解题报告（二分法）]]></title>
    <url>%2Fpost%2FPAT_1085%2F</url>
    <content type="text"><![CDATA[1085 Perfect Sequence题目1085 Perfect Sequence （25 分）Given a sequence of positive integers and another positive integer p. The sequence is said to be a perfect sequence if M≤m×p where M and m are the maximum and minimum numbers in the sequence, respectively. Now given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence. Input Specification:Each input file contains one test case. For each case, the first line contains two positive integers N and p, where N (≤10^5) is the number of integers in the sequence, and p (≤10^9 ) is the parameter. In the second line there are N positive integers, each is no greater than 10^9​ . Output Specification:For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence. Sample Input:10 82 3 20 4 5 1 6 7 8 9Sample Output:8 思路首先是想到先排个序。排完序想了一下动态规划没法做，如果直接暴力搜索，需要O(N2)的时间复杂度，对于N~10^5来说估计是过不了的，那就二分法吧。对于每个序列中的最小值，通过二分法来找到使序列最长的最大值。二分法处理的时候，考虑到序列中可能会有相同的元素，要使序列最长，所以vec[mid] ==vec[i]*p的情况需要继续向右搜索，这样得到的就是一串相同数字中最后一个数字右边的位置。所以right初始化的时候设置为vec.size()而不是vec.size()-1。输入：10 81 1 2 3 4 5 6 7 8 8输出：10 代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; vec;int main()&#123; long long N,p; cin &gt;&gt; N &gt;&gt; p; vec.resize(N); for(int i=0;i&lt;N;i++) cin &gt;&gt; vec[i]; sort(vec.begin(),vec.end()); int maxL = 0; for(int i=0;i&lt;vec.size();i++)&#123; int left = i,right = vec.size(); int mid; while(left&lt;right)&#123; mid = (left+right)/2; if(vec[mid] &gt;vec[i]*p) &#123; right = mid-1; &#125; else left = mid+1; &#125; if(left-i&gt;maxL) &#123; maxL = left-i; &#125; &#125; cout &lt;&lt; maxL; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1074解题报告（模拟链表）]]></title>
    <url>%2Fpost%2FPAT_1074%2F</url>
    <content type="text"><![CDATA[1074 Reversing Linked List题目1074 Reversing Linked List （25 分）Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤10^5) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N lines follow, each describes a node in the format: Address Data Nextwhere Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:00100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218Sample Output:00000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 思路一开始直接当作链表来处理，逻辑相当复杂，指针飞来飞去的简直要崩溃，勉强AC了。看了一下别人的答案，原来直接用一个数组来模拟链表就好，牺牲了空间复杂度，但是代码非常的简单易懂。 ##代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include &lt;iostream&gt;//#include &lt;iomanip&gt;//using namespace std;//int Data[100000+10];//int Next[100000+10];//int Add[100000+10];//int main()//&#123;// int head,N,K;// cin &gt;&gt; head &gt;&gt; N &gt;&gt; K;// int add;// for(int i=0;i&lt;N;i++)&#123;// cin &gt;&gt; add;// cin &gt;&gt; Data[add] &gt;&gt; Next[add];// &#125;// Next[100000+5] = head;// if(K&gt;1)&#123;// int now = 100000+5;// while(true)&#123;//// cout &lt;&lt; "now: " &lt;&lt;now &lt;&lt; endl;// int k=0;// while(k&lt;=K+1)&#123;// Add[k] = now;//// cout &lt;&lt; "Add: " &lt;&lt; k &lt;&lt; " " &lt;&lt; Add[k] &lt;&lt; endl;// k++;// if(now==-1) break;// now = Next[now];// &#125;// if(k==K+2)&#123;// Next[Add[0]] = Add[K];// Next[Add[1]] = Add[K+1];// for(int i=2;i&lt;=K;i++)&#123;// Next[Add[i]] = Add[i-1];// &#125;// &#125;else break;// now = Add[1];// &#125;//// &#125;// int now = Next[100000+5];// while(now!=-1)&#123;// cout.width(5);cout.fill('0');// cout &lt;&lt; now &lt;&lt; " " &lt;&lt; Data[now] &lt;&lt; " ";// now = Next[now];// if(now!=-1)&#123; cout.width(5);cout.fill('0');&#125;// cout &lt;&lt; now &lt;&lt; "\n";// &#125;//// return 0;//&#125;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int Data[100000+10];int Next[100000+10];int Add[100000+10];int main()&#123; int head,N,K; cin &gt;&gt; head &gt;&gt; N &gt;&gt; K; int address; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt;address; cin &gt;&gt; Data[address] &gt;&gt; Next[address]; &#125; int num = 0; while(head!=-1)&#123; Add[num++] = head; head = Next[head]; &#125; for(int i=0;i&lt;num/K;i++)&#123; reverse(Add+K*i,Add+K*i+K); &#125; for(int i=0;i&lt;num-1;i++)&#123; printf("%05d %d %05d\n",Add[i],Data[Add[i]],Add[i+1]);// cout &lt;&lt; Add[i] &lt;&lt; " " &lt;&lt; Data[Add[i]] &lt;&lt; " " &lt;&lt; Add[i+1]&lt;&lt; "\n"; &#125; printf("%05d %d %d\n",Add[num-1],Data[Add[num-1]],-1); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1072解题报告（图，Dijkstra算法）]]></title>
    <url>%2Fpost%2FPAT_1072%2F</url>
    <content type="text"><![CDATA[1072 Gas Station题目1072 Gas Station （30 分）A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range. Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number. Input Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers: N (≤10^3), the total number of houses; M (≤10), the total number of the candidate locations for the gas stations; K (≤10^4), the number of roads connecting the houses and the gas stations; and DS, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM. Then K lines follow, each describes a road in the format P1 P2 Distwhere P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road. Output Specification:For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution. Sample Input 1:4 3 11 51 2 21 4 21 G1 41 G2 32 3 22 G2 13 4 23 G3 24 G1 3G2 G1 1G3 G2 2Sample Output 1:G12.0 3.3Sample Input 2:2 1 2 101 G1 92 G1 20Sample Output 2:No Solution 思路题目给出一个图，图中包括N个房子节点和M个候选加油站节点，需要找到一个加油站满足以下条件：1.到各个房子的最短距离最大2.如果满足1的不止一个，到各个房子的平均距离最小3.如果满足1，2的不止一个，序号最小这其实是个多源最短路径，但是由于M比较小，直接调用M次Dijkstra算法就好，每次调用完计算一下到各个房子的最短距离、平均距离等信息，最后找到最优解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3fffffff;const int MAXV = 1020;int N,M,K,D;int Graph[MAXV][MAXV];bool collected[MAXV];int dist[MAXV];int FindMinVertex()&#123; int minDist = INF,minV = -1; for(int i=1;i&lt;=N+M;i++)&#123; if(!collected[i]&amp;&amp;dist[i]&lt;minDist)&#123; minDist = dist[i]; minV = i; &#125; &#125;// cout &lt;&lt; "Find: " &lt;&lt; minV &lt;&lt; endl; return minV;&#125;void Dijkstra(int source)&#123; fill(dist+1,dist+N+M+1,INF); fill(collected+1,collected+N+M+1,false); dist[source] = 0; while(true)&#123; int minV = FindMinVertex(); if(minV==-1) break; collected[minV] = true; for(int i=1;i&lt;=N+M;i++)&#123; if(!collected[i]&amp;&amp;dist[minV] + Graph[minV][i]&lt;dist[i])&#123; dist[i] = dist[minV] + Graph[minV][i];// cout &lt;&lt;"dist: " &lt;&lt; i &lt;&lt; " " &lt;&lt; dist[i] &lt;&lt; " " &lt;&lt;Graph[minV][i] &lt;&lt;endl; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M&gt;&gt; K &gt;&gt; D; fill(Graph[0],Graph[0]+MAXV*MAXV,INF); string P1,P2; int p1,p2; int Dist; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; P1 &gt;&gt; P2 &gt;&gt; Dist; if(P1[0]=='G') p1 = stoi(P1.substr(1))+N; else p1 = stoi(P1); if(P2[0]=='G') p2 = stoi(P2.substr(1))+N; else p2 = stoi(P2); Graph[p1][p2] = min(Graph[p1][p2],Dist); Graph[p2][p1] = Graph[p1][p2]; &#125; int bestV = -1; double average = INF; double minimum = -1; for(int i=N+1;i&lt;=N+M;i++)&#123; Dijkstra(i); double sum=0; double mini = INF; int j; for(j=1;j&lt;=N;j++)&#123; if(dist[j]&gt;D) break; sum+=dist[j]; if(dist[j]&lt;mini) mini = dist[j]; &#125; if(j!=N+1) continue; if(mini &gt; minimum||mini==minimum&amp;&amp;sum/N&lt;average)&#123; average = sum/N; minimum = mini; bestV = i-N; &#125; &#125; cout.setf(ios::fixed); cout.precision(1); if(bestV!=-1)&#123; cout &lt;&lt; "G" &lt;&lt; bestV &lt;&lt; "\n"; cout &lt;&lt; minimum+eps &lt;&lt; " " &lt;&lt; average+eps; &#125; else&#123; cout &lt;&lt; "No Solution"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1067解题报告]]></title>
    <url>%2Fpost%2FPAT_1067%2F</url>
    <content type="text"><![CDATA[1067 Sort with Swap(0, i)题目1067 Sort with Swap(0, i) （25 分）Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: Swap(0, 1) =&gt; {4, 1, 2, 0, 3}Swap(0, 3) =&gt; {4, 1, 2, 3, 0}Swap(0, 4) =&gt; {0, 1, 2, 3, 4}Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers. Input Specification:Each input file contains one test case, which gives a positive N (≤10^5) followed by a permutation sequence of {0, 1, …, N−1}. All the numbers in a line are separated by a space. Output Specification:For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input:103 5 7 2 6 4 9 0 8 1Sample Output:9 思路表排序-物理排序的问题。看了姥姥的课又回忆了一下表排序。题目要求通过“与0交换”这个操作对序列进行排序。首先通过物理排序的方法，看一下序列中存在几个环（只有一个元素的环，即不需移动的元素不用管），然后可以发现，记第i个环中的元素个数为n_i，如果环中存在元素0，那么只需要进行n_i-1次交换，如果不存在元素0，需要将环中的一个元素与0进行交换，对形成的新的包含0的环再进行如上所述交换，即需要n_i+1次交换。所以只需要记录所有需要交换的元素的个数，然后每多一个不包含0的环，需要交换的总数需要额外加1，如果有包含0的环，那么需要交换的总数就额外减1。即可得到以下代码： 代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int table[100000+10];int main()&#123; int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; table[i]; int n = 0; for(int i=0;i&lt;N;i++)&#123; if(table[i]!=i)&#123; if(i==0)n--; else n++; int j = i; while(table[j]!=j)&#123; n++;// cout &lt;&lt; j &lt;&lt; " " &lt;&lt; table[j]&lt;&lt; endl; int tmp = table[j]; table[j] = j; j = tmp; &#125; &#125; &#125; cout &lt;&lt; n; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1060解题报告]]></title>
    <url>%2Fpost%2FPAT_1060%2F</url>
    <content type="text"><![CDATA[1060 Are They Equal题目1060 Are They Equal （25 分）If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×10^5 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification:Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^​100, and that its total digit number is less than 100. Output Specification:For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]…d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1:3 12300 12358.9Sample Output 1:YES 0.12310^5Sample Input 2:3 120 128Sample Output 2:NO 0.12010^3 0.128*10^3 思路题目要求主要就是给定有效数字，把一个浮点数用科学记数法表示出来。数字有100位，所以基本只能用字符串来表示，并进行处理了。直接通过一次扫描，扫描的过程中把位数等信息保存下来。细节很多，很多小坑。容易出错的输入包括0.0001234, 0.00000等。to_string()可以把数字转换为字符串，很好用。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;string chop(string s,int sigDigits)&#123; string ret = "0."; bool isPositive = s[0]!='-'; int digit = 0; bool afterPoint = false; bool firstZero = true; for(int i = 1-isPositive;i&lt;s.size();i++)&#123; if(firstZero&amp;&amp;s[i]=='0') &#123; if(afterPoint) digit--; continue; &#125; if(s[i] == '.') &#123; afterPoint = true; continue; &#125; firstZero = false; if(ret.size()&lt;sigDigits+2) ret.push_back(s[i]); if(!afterPoint) digit++; &#125; if(firstZero) digit = 0;//数字为0则将位数置为0，否则输入0.000会出错 while(ret.size()&lt;sigDigits+2) ret+="0"; ret+= "*10^" + to_string(digit); if(!isPositive) ret = "-" + ret; return ret;&#125;int main()&#123; int N; string A,B; string Ac,Bc; cin &gt;&gt; N &gt;&gt; A &gt;&gt; B; Ac = chop(A,N); Bc = chop(B,N); if(Ac==Bc) &#123; cout &lt;&lt; "YES " &lt;&lt; Ac; &#125; else &#123; cout &lt;&lt; "NO " &lt;&lt; Ac &lt;&lt; " " &lt;&lt; Bc; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1052解题报告]]></title>
    <url>%2Fpost%2FPAT_1052%2F</url>
    <content type="text"><![CDATA[1052 Linked List Sorting题目1052 Linked List Sorting （25 分）A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification:Each input file contains one test case. For each case, the first line contains a positive N (&lt;10^5 ) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the address of the node in memory, Key is an integer in [−10^​5​​,10^​5​ ], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification:For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input:5 0000111111 100 -100001 0 2222233333 100000 1111112345 -1 3333322222 1000 12345Sample Output:5 1234512345 -1 0000100001 0 1111111111 100 2222222222 1000 3333333333 100000 -1 思路一开始没考虑到链表中还有无效的数据，直接把所有节点排序，然后有几个case过不了。先从头开始，沿着next的顺序读一遍，存到数组里，然后排个序再输出就好。更小空间复杂度的方法是在Node加一个flag判断是否读取，在排序的时候把无效的节点排到最后，再输出前面有效的n个节点即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Node&#123; int address,key,next; friend bool operator&lt;(Node n1,Node n2)&#123; return n1.key&lt;n2.key; &#125;&#125;;vector&lt;Node&gt; vN;Node aN[100000];int main()&#123; ios::sync_with_stdio(false); int N,st; cin &gt;&gt; N &gt;&gt; st; int address,key,next; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; address &gt;&gt; key &gt;&gt; next; aN[address] = Node&#123;address,key,next&#125;; &#125; while(st!=-1)&#123; vN.push_back(aN[st]); st = aN[st].next; &#125; sort(vN.begin(),vN.end()); cout &lt;&lt; vN.size() &lt;&lt; " "; if(vN.size()&gt;0)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[0].address &lt;&lt; "\n"; &#125; else&#123; cout &lt;&lt; "-1"; return 0; &#125; for(int i=0;i&lt;vN.size();i++)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[i].address &lt;&lt; " " &lt;&lt; vN[i].key &lt;&lt; " "; if(i!=vN.size()-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[i+1].address; &#125; else cout &lt;&lt; "-1"; cout &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1045解题报告]]></title>
    <url>%2Fpost%2FPAT-1045%2F</url>
    <content type="text"><![CDATA[1045 Favorite Color Stripe题目1045 Favorite Color Stripe （30 分）Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (≤200) followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (≤10^4) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line a separated by a space. Output Specification:For each test case, simply print in a line the maximum length of Eva’s favorite stripe. Sample Input:65 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6Sample Output:7 思路算是我做的第二道动态规划题目，想明白了之后还是很简单的，我都不敢相信这么简单。题目类似最长公共子序列，但是序列a中的元素允许再序列b中重复多次。记dp[i][j]为a[1]~a[i]与b[1]~b[j]的最长可重复公共子序列，那么有状态转移方程：如果a[i] = b[j], dp[i][j] = dp[i][j-1] +1，因为a[i]可能在b[j]前出现过，所以i不用变如果a[i] != b[j], dp[i][j] = max(dp[i-1][j],dp[i][j-1])边界条件即dp[i][0] = 0,dp[j][0] = 0，这个条件在初始化dp的时候已经实现了。 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int a[201];int b[10001];int dp[201][10001];int main()&#123; int N,L,M; cin &gt;&gt; N; cin &gt;&gt; M; for(int i=1;i&lt;=M;i++) cin &gt;&gt; a[i]; cin &gt;&gt; L; for(int i=1;i&lt;=L;i++) cin &gt;&gt; b[i]; int maxLen = 0; for(int i=1;i&lt;=M;i++)&#123; for(int j=1;j&lt;=L;j++)&#123; if(a[i]==b[j]) dp[i][j] = dp[i][j-1]+1; else dp[i][j] = max(dp[i][j-1],dp[i-1][j]); if(dp[i][j]&gt;maxLen) maxLen = dp[i][j]; &#125; &#125; cout &lt;&lt; maxLen; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1044解题报告]]></title>
    <url>%2Fpost%2FPAT-1044%2F</url>
    <content type="text"><![CDATA[1044 Shopping in Mars题目1044 Shopping in Mars （25 分）Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15).Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤10^​5​​ ), the total number of diamonds on the chain, and M (≤10^8​​ ), the amount that the customer has to pay. Then the next line contains N positive numbers D1​​ ⋯D​N​​ (D​i​​ ≤10^​3 for all i=1,⋯,N) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification:For each test case, print i-j in a line for each pair of i ≤ j such that Di + … + Dj = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i. If there is no solution, output i-j for pairs of i ≤ j such that Di + … + Dj &gt;M with (Di + … + Dj −M) minimized. Again all the solutions must be printed in increasing order of i. It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1:16 153 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13Sample Output 1:1-54-67-811-11Sample Input 2:5 132 4 5 7 9Sample Output 2:2-44-5 思路将前i个数的和保存在sum数组中，然后从i到j的和就是sum[j]-sum[i]。一开始直接两重循环来做，O(n^2)的复杂度，果然两个case超时了。改用二分查找就通过了。注意二分查找的写法，在找不到时返回大于查找值的第一个位置。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int dc[100010];long long sum[100010];int N,M;int Half(int i)&#123; int left = i; int right = N; int mid; while(left&lt;right)&#123;// cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; " right: " &lt;&lt;right &lt;&lt; endl; mid = (left+right)/2; if(sum[mid]-sum[i-1]&lt;M) left = mid+1; else if(sum[mid]-sum[i-1]&gt;M) right = mid; else return mid; &#125; return left;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M; for(int i=0;i&lt;N;i++) cin &gt;&gt; dc[i]; sum[0] = 0; for(int i=1;i&lt;=N;i++) sum[i] = sum[i-1] + dc[i-1];// for(int i=0;i&lt;=N;i++) cout &lt;&lt; sum[i] &lt;&lt;" ";// cout &lt;&lt; endl; vector&lt;int&gt; v; long long minMoney = 0x3fffffff; for(int i=1;i&lt;=N;i++)&#123; int tmp = Half(i);// cout &lt;&lt; "Half" &lt;&lt; i &lt;&lt; " " &lt;&lt; tmp &lt;&lt; endl; if(sum[tmp] - sum[i-1] &lt; M) continue; if(sum[tmp]-sum[i-1] &lt; minMoney)&#123; minMoney = sum[tmp]-sum[i-1];// cout &lt;&lt; "minMoney: " &lt;&lt; minMoney &lt;&lt; endl; v.clear(); v.push_back(i); v.push_back(tmp); &#125; else if(sum[tmp] - sum[i-1] == minMoney)&#123; v.push_back(i); v.push_back(tmp); &#125; &#125;// cout &lt;&lt; minMoney &lt;&lt; endl; for(int i=0;i&lt;v.size()/2;i++)&#123; cout &lt;&lt; v[2*i] &lt;&lt; "-" &lt;&lt; v[2*i+1] &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1043解题报告]]></title>
    <url>%2Fpost%2FPAT-1043%2F</url>
    <content type="text"><![CDATA[1043 Is It a Binary Search Tree题目1043 Is It a Binary Search Tree （25 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST. Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:78 6 5 7 10 8 11Sample Output 1:YES5 7 6 8 11 10 8Sample Input 2:78 10 11 8 6 7 5Sample Output 2:YES11 8 10 7 5 6 8Sample Input 3:78 6 8 5 10 9 11Sample Output 3:NO 思路一开始又SB的以为preOrder是左中右的访问顺序，结果题目都读不懂。读懂题目之后，就假设是序列是BST，然后来递归的建立这棵树。首先以BST（非镜像），以8 6 5 7 10 8 11为例，首先由于是先序遍历，8就是根，左子树就是右边序列6 5 7 10 8 11中小于根的部分，右子树就是大于等于根的序列。用i从左到右的扫描，到大于等于根的地方停下，j从又往左扫描到小于根的地方停下。如果i+1=j，那么符合BST的条件，继续递归的生成左子树和右子树，否则不满足BST的条件，所有递归都中止。一开始在扫描的时候没有判断扫描的终点，导致一不小心就扫描出了[from,to]的范围，甚至出现段错误。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;typedef struct Node *Tree;struct Node&#123; int value; Tree left,right;&#125;;int seq[1010];int N;bool isBST = true;bool first = true;Tree buildTree(int from,int to)&#123; if(!isBST) return NULL; if(from &gt; to) return NULL; if(from==to) return new Node&#123;seq[from],NULL,NULL&#125;; int i=from,j=to+1; while(seq[i+1]&lt;seq[from]&amp;&amp;i&lt;=to-1) i++; while(seq[j-1]&gt;=seq[from]&amp;&amp;j&gt;=from+2) j--; if(i+1==j)&#123; return new Node&#123;seq[from],buildTree(from+1,i),buildTree(j,to)&#125;; &#125; else&#123; isBST = false; return NULL; &#125;&#125;Tree buildTreeM(int from,int to)&#123; if(!isBST) return NULL; if(from &gt; to) return NULL; if(from==to) return new Node&#123;seq[from],NULL,NULL&#125;; int i=from,j=to+1; while(seq[i+1]&gt;=seq[from]&amp;&amp;i&lt;=to-1) i++; while(seq[j-1]&lt;seq[from]&amp;&amp;j&gt;=from+2) j--; if(i+1==j)&#123; return new Node&#123;seq[from],buildTreeM(from+1,i),buildTreeM(j,to)&#125;; &#125; else&#123; isBST = false; return NULL; &#125;&#125;void postOrder(Tree t)&#123; if(t-&gt;left) postOrder(t-&gt;left); if(t-&gt;right) postOrder(t-&gt;right); if(first) first = false; else cout &lt;&lt;" "; cout &lt;&lt; t-&gt;value;&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; seq[i]; &#125; if(N==0)&#123; cout &lt;&lt; "YES\n"; return 0; &#125; Tree t = buildTree(0,N-1); if(isBST)&#123; cout &lt;&lt; "YES\n"; postOrder(t); &#125; else &#123; isBST = true; t = buildTreeM(0,N-1); if(isBST)&#123; cout &lt;&lt; "YES\n"; postOrder(t); &#125; else&#123; cout &lt;&lt; "NO\n"; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1040解题报告]]></title>
    <url>%2Fpost%2FPAT-1040%2F</url>
    <content type="text"><![CDATA[1040 Longest Symmetric String题目1040 Longest Symmetric String （25 分）Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11. Input Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification:For each test case, simply print the maximum length in a line. Sample Input:Is PAT&amp;TAP symmetric?Sample Output:11 思路第一次做动态规划的题目……参照《算法笔记》中动态规划的内容。bool dp[i]j用来记录从i到j的子串是否为回文字符串。状态转移方程也很简单：dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == s[j]。问题是如何从边界出发计算整个数组，采用的方法是先初始化长度为1和2的子串，然后从3开始计算，一直计算完整个字符串。字符串长度为1的时候，初始化长度为2的字串会读取到’\0’因而不会产生错误。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;bool dp[1010][1010];int main()&#123; int maxLen = 1; char s[1010]; cin.getline(s,1010); int len = 0; while(s[len++]!='\0'); for(int i=0;i&lt;len;i++)&#123; dp[i][i] = true; &#125; for(int i=0;i&lt;len-1;i++)&#123; if(s[i]==s[i+1])&#123; dp[i][i+1] = true; maxLen = 2; &#125; &#125; for(int L = 3;L&lt;=len;L++)&#123; for(int i=0;i&lt;len-L+1;i++)&#123; if(dp[i+1][i+L-2]==true&amp;&amp;s[i]==s[i+L-1])&#123; dp[i][i+L-1] = true; maxLen = L; &#125; &#125; &#125; cout &lt;&lt; maxLen; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1039解题报告]]></title>
    <url>%2Fpost%2FPAT_1039%2F</url>
    <content type="text"><![CDATA[1039 Course List for Student题目1039 Course List for Student （25 分）Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤40,000), the number of students who look for their course lists, and K (≤2,500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students N_i​​(≤200) are given in a line. Then in the next line, N_​i student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification:For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student’s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input:11 54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE11 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB55 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9Sample Output:ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5NON9 0 思路好简单的题目，map&lt;string,vector&lt;int&gt; &gt;就好。发现最后一个点超时了没过，考虑到数据量比较大，把输入输出优化ios::sync_with_stdio(false)加上就刚好过了~看了一下其他人的做法，因为名字都很有规律，可以直接转换成int型存在数组里，效率肯定比map要高不少。 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;map&lt;string,vector&lt;int&gt; &gt; m;int main()&#123; ios::sync_with_stdio(false); int N,K; cin &gt;&gt; N &gt;&gt; K; int index,num; string name; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; index &gt;&gt; num; for(int i=0;i&lt;num;i++)&#123; cin &gt;&gt; name; m[name].push_back(index); &#125; &#125; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; name; sort(m[name].begin(),m[name].end()); cout &lt;&lt; name &lt;&lt; " "; cout &lt;&lt; m[name].size(); for(int j=0;j&lt;m[name].size();j++)&#123; cout &lt;&lt; " " &lt;&lt; m[name][j]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125; 不使用map的版本，最后一个case的用时比上面的版本降低了一半，但是其他case的用时都增加了一倍左右好奇怪。更诡异的是str2int函数改为引用传参的方式case的用时也会增加…… 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; v[200000];int str2int(string &amp;s)&#123; return (s[0]-'A')*26*26*10+(s[1]-'A')*26*10+(s[2]-'A')*10+s[3]-'0';&#125;int main()&#123; ios::sync_with_stdio(false); int N,K; cin &gt;&gt; N &gt;&gt; K; int index,num; string name; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; index &gt;&gt; num; for(int i=0;i&lt;num;i++)&#123; cin &gt;&gt; name; v[str2int(name)].push_back(index); &#125; &#125; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; name; sort(v[str2int(name)].begin(),v[str2int(name)].end()); cout &lt;&lt; name &lt;&lt; " "; cout &lt;&lt; v[str2int(name)].size(); for(int j=0;j&lt;v[str2int(name)].size();j++)&#123; cout &lt;&lt; " " &lt;&lt; v[str2int(name)][j]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1017解题报告]]></title>
    <url>%2Fpost%2FPAT_1017%2F</url>
    <content type="text"><![CDATA[1017 Queueing at Bank题目1017 Queueing at Bank （25 分）Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour. Now given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤10^4) - the total number of customers, and K (≤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time. Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average. Output Specification:For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place. Sample Input:7 307:55:00 1617:00:01 207:59:59 1508:01:00 6008:00:00 3008:00:02 208:03:00 10Sample Output:8.2 思路思路参照陈越姥姥的《数据结构》8.1银行排队问题，细节有点多，很容易写错。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int N,K;int crtTime;int totalTime = 0;int cusNum;struct Customer&#123; int arrive,process; friend bool operator&lt; (Customer c1,Customer c2)&#123; return c1.arrive&gt;c2.arrive; &#125;&#125;;priority_queue&lt;Customer&gt; waitingLine;vector&lt;int&gt; windowsTime;int time(int hh,int mm,int ss)&#123; return hh*3600+mm*60+ss;&#125;int findNextWindows()&#123; int nextWin; int minTime = 999999; for(int i=0;i&lt;K;i++)&#123; if(windowsTime[i]&lt;minTime)&#123; minTime = windowsTime[i]; nextWin = i; &#125; &#125; for(int i=0;i&lt;K;i++) windowsTime[i]-=minTime; crtTime+=minTime; return nextWin;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K; windowsTime.resize(K); fill(windowsTime.begin(),windowsTime.end(),0); int hh,mm,ss,process; char c; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; hh &gt;&gt; c; cin &gt;&gt; mm &gt;&gt; c; cin &gt;&gt; ss &gt;&gt; process; if(time(hh,mm,ss)&lt;=time(17,0,0)) waitingLine.push(Customer&#123;time(hh,mm,ss),process*60&#125;); &#125; cusNum = waitingLine.size(); crtTime = time(8,0,0); while(!waitingLine.empty())&#123; Customer cus = waitingLine.top(); waitingLine.pop(); int nextWin = findNextWindows(); if(cus.arrive&lt;=crtTime)&#123; totalTime+= crtTime-cus.arrive;// cout &lt;&lt; "wait time: " &lt;&lt; crtTime-cus.arrive &lt;&lt; endl; &#125; else&#123; for(int i=0;i&lt;K;i++)&#123; windowsTime[i] = max(windowsTime[i]-(cus.arrive-crtTime),0); &#125; crtTime = cus.arrive; &#125; windowsTime[nextWin] = cus.process; &#125; cout.setf(ios::fixed); cout.precision(1); cout &lt;&lt; double(totalTime)/cusNum/60&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1100,1101,1102,1103解题报告]]></title>
    <url>%2Fpost%2FPAT_1100_1101_1102_1103%2F</url>
    <content type="text"><![CDATA[1100 Mars Numbers题目1100 Mars Numbers （20 分）People on Mars count their numbers with base 13: Zero on Earth is called “tret” on Mars.The numbers 1 to 12 on Earch is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.For the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.For examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars. Output Specification:For each number, print in a line the corresponding number in the other language. Sample Input:4295elo novtamSample Output:hel marmay11513 思路送分题，注意输入输出格式。除非数字本身是零，否则不输出某位上的零。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;map&lt;string,int&gt; str2num = &#123;&#123;"tret",0&#125;,&#123;"jan",1&#125;,&#123;"feb",2&#125;,&#123;"mar",3&#125;,&#123;"apr",4&#125;, &#123;"may",5&#125;,&#123;"jun",6&#125;,&#123;"jly",7&#125;, &#123;"aug",8&#125;,&#123;"sep",9&#125;,&#123;"oct",10&#125;,&#123;"nov",11&#125;,&#123;"dec",12&#125;,&#123;"tam",1*13&#125;,&#123;"hel",2*13&#125;,&#123;"maa",3*13&#125;,&#123;"huh",4*13&#125;, &#123;"tou",5*13&#125;,&#123;"kes",6*13&#125;,&#123;"hei",7*13&#125;, &#123;"elo",8*13&#125;,&#123;"syy",9*13&#125;,&#123;"lok",10*13&#125;,&#123;"mer",11*13&#125;,&#123;"jou",12*13&#125;&#125;;string num2str1[] = &#123;"tret","jan","feb","mar","apr","may","jun","jly","aug","sep","oct","nov","dec"&#125;;string num2str2[] = &#123;"tret","tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mer","jou"&#125;;void ToMars(string s)&#123; int num=0; for(int i=0;i&lt;s.size();i++) num = num*10+ s[i]-'0'; if(num==0)&#123; cout &lt;&lt; num2str1[0] &lt;&lt; "\n"; return; &#125; if(num/13!=0) cout &lt;&lt; num2str2[num/13]; if(num%13!=0)&#123; if(num/13!=0) cout &lt;&lt; " "; cout &lt;&lt; num2str1[num%13]; &#125; cout &lt;&lt; "\n";&#125;void ToEarth(string s1,string s2)&#123; if(s2=="")&#123; cout &lt;&lt; str2num[s1] &lt;&lt; "\n"; &#125; else&#123; cout &lt;&lt; str2num[s2] + str2num[s1] &lt;&lt; "\n"; &#125;&#125;int main()&#123; int N; cin &gt;&gt; N; string s1,s2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; s1; s2 = ""; if(cin.get()!='\n') cin &gt;&gt; s2; if(s2==""&amp;&amp;isdigit(s1[0])) ToMars(s1); else ToEarth(s1,s2); &#125; return 0;&#125; 1101 Quick Sort题目There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;and for the similar reason, 4 and 5 could also be the pivot.Hence in total there are 3 pivot candidates. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10​5​​ ). Then the next line contains N distinct positive integers no larger than 10​9​​ . The numbers in a line are separated by spaces. Output Specification:For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:51 3 2 4 5Sample Output:31 4 5 思路没什么思路，先想着枚举法试一下，果然好几个点过不了。然后看了一下网上的做法，原来这么简单……思想就是如果某个位置的数字比左边的最大值还要大，并且比右边的最小值还要小，那么这个数就是pivot。那就先从左向右扫描一次，求出maxL[i]，即下标从0到i位置上最大的数；同理从右向左扫描一次，求出minR[i]。如果maxL[i]==minR[i]的话那这个数就可以作为pivot。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int num[100010];int maxL[100010];int minR[100010];vector&lt;int&gt; v;int main()&#123; ios::sync_with_stdio(false); int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; num[i]; int max = num[0]; for(int i=0;i&lt;N;i++)&#123; if(num[i]&gt;max) max = num[i]; maxL[i] = max; &#125; int min = num[N-1]; for(int i=N-1;i&gt;=0;i--)&#123; if(num[i]&lt;min) min = num[i]; minR[i] = min; &#125; for(int i=0;i&lt;N;i++)&#123; if(num[i]==maxL[i] &amp;&amp; num[i] == minR[i]) v.push_back(num[i]); &#125; sort(v.begin(),v.end()); int len = v.size(); cout &lt;&lt; len &lt;&lt; "\n"; for(int i=0;i&lt;len;i++)&#123; if(i!=0) cout &lt;&lt; " "; cout &lt;&lt; v[i]; &#125; cout &lt;&lt; "\n"; return 0;&#125; 1102 Invert a Binary Tree题目1102 Invert a Binary Tree （25 分）The following is from Max Howell @twitter: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.Now it’s your turn to prove that YOU CAN invert a binary tree! Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node from 0 to N−1, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification:For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:81 -- -0 -2 7- -- -5 -4 6Sample Output:3 7 2 6 4 0 5 16 5 7 4 3 2 0 1 思路听过这个故事的，反转二叉树感觉真的不难呀- -不过其实这道题目并不用反转，只要遍历的时候，把正常的先左节点后右节点的顺序反过来就好。还有需要注意的就是树的根节点并不是从0开始，所以要先找一下根节点。水题一道。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int nLeft[10];int nRight[10];bool isChild[10];queue&lt;int&gt; Q;int root;bool first=true;void inOrder(int n)&#123; if(nRight[n]!=-1) inOrder(nRight[n]); if(first) first = false; else cout &lt;&lt; " "; cout &lt;&lt; n; if(nLeft[n]!=-1) inOrder(nLeft[n]);&#125;int main()&#123; int N; cin &gt;&gt; N; char c1,c2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; c1 &gt;&gt; c2; nLeft[i] = c1=='-'?-1:(c1-'0'); nRight[i] = c2=='-'?-1:(c2-'0'); &#125; //find root for(int i=0;i&lt;N;i++)&#123; if(nLeft[i]!=-1) isChild[nLeft[i]] = true; if(nRight[i]!=-1) isChild[nRight[i]] = true; &#125; for(int i=0;i&lt;N;i++) &#123; if(!isChild[i]) root = i; &#125; //level order Q.push(root); while(!Q.empty())&#123; int tmp = Q.front(); if(tmp!=root) cout &lt;&lt; " "; cout &lt;&lt; tmp; Q.pop(); if(nRight[tmp]!=-1) Q.push(nRight[tmp]); if(nLeft[tmp]!=-1) Q.push(nLeft[tmp]); &#125; cout &lt;&lt; "\n"; //in-order travelsal inOrder(root); return 0;&#125; 1103 Integer Factorization题目 思路想了半天，感觉是DFS，但是还是无从下手……参考了柳神的代码，但是该代码在我电脑上运行有问题，double的pow强制类型转换成int之后会产生误差。好了说一下思路，这就是一个DFS+剪枝的问题，首先初始化一个powP数组以避免重复进行次方运算。然后用tmpSeq来临时记录当前的“路径”。然后开始dfs：递归终止的条件是因数的数量达到了K，然后判断一下当前的k个数是否满足题目的条件，如果满足并且facSum更大，就记录下来。如果没有达到k个数，就继续往下递归。往下递归需要注意：1.下一个数的上界的选取，第一个数就取sqrt(N)，后面的数的上界是前一个数（由于对称性，只需要考虑降序排列的情况，否则计算量将急剧增加）。2.当sum+powP[i]&lt;=N时才向下递归 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int N,K,P;int powP[30];vector&lt;int&gt; bestSqe;vector&lt;int&gt; tmpSqe;int maxFacSum =-1;int bound;void powInit()&#123; powP[0] = 0;powP[1] = 1; int sum=1,i=2,p; while(sum&lt;=N) &#123; sum = 1; p = P; while(p--) sum*=i; powP[i] = sum; i++; &#125; bound = i-1;&#125;//k：第k个数//sum：前k个因数的P次方的和//facSum：前k个因数的和void dfs(int k,int sum,int facSum)&#123;// cout &lt;&lt; k &lt;&lt;" " &lt;&lt;sum &lt;&lt; " " &lt;&lt; facSum &lt;&lt; endl; if(k==K)&#123; if(sum == N&amp;&amp;facSum&gt;maxFacSum)&#123; bestSqe = tmpSqe; maxFacSum = facSum; &#125; return; &#125; //确保序列是递减的 int upBound = k==0?bound:tmpSqe[k-1]; for(int i = upBound;i&gt;=1;i--)&#123; if(sum+powP[i]&lt;=N)&#123; tmpSqe[k] = i; dfs(k+1,sum+powP[i],facSum+i); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; P; powInit(); tmpSqe.resize(K); dfs(0,0,0); if(maxFacSum==-1)&#123; cout &lt;&lt; "Impossible\n"; return 0; &#125; cout &lt;&lt; N &lt;&lt; " = "; for(int i=0;i&lt;bestSqe.size();i++)&#123; if(i!=0) cout &lt;&lt; " + "; cout &lt;&lt; bestSqe[i]&lt;&lt; "^" &lt;&lt; P; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1096,1097,1098,1099解题报告]]></title>
    <url>%2Fpost%2FPAT_1096_1097_1098_1099%2F</url>
    <content type="text"><![CDATA[1096 Consecutive Factors题目1096 Consecutive Factors （20 分） Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification:Each input file contains one test case, which gives the integer N (1&lt;N&lt;2^​31​). Output Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]factor[2]…*factor[k], where the factors are listed in increasing order, and 1 is NOT included. Sample Input:630Sample Output:3567 思路题目的意思是让找到一个整数最长的连续的因数（不是质因数）。一开始完全没头绪的题目，一开始想先分解成质因数，但是因数的组合也很麻烦……那就不妨暴力求解一下~虽然知道因子的上界是sqrt(N),但一开始偷懒先写的是N/2，果然有一个测试点过不了。然后想想，2^31数量级的情况下，sqrt(N)和N/2差了好多好多。改成sqrt(N)就果断过了。注意要用&lt;=,否则N=4的时候会出错。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt; factors;int main()&#123; int N; cin &gt;&gt; N; int maxNum = 1; factors.push_back(N); int sq = sqrt(N); //num个连续因子 for(int num = 1;num&lt;13;num++)&#123; //连续因子从start开始 bool end = false; for(int start = 2;start&lt;=sq;start++)&#123; //计算是否存在合适的连续因子 int product = 1; for(int i=start;i&lt;start+num;i++) product*=i; if(product&gt;N)&#123; end = true; break; &#125;else if(N%product==0)&#123; factors.clear(); for(int i = start;i&lt;start+num;i++) &#123; factors.push_back(i); &#125; maxNum = num; break; &#125; &#125; if(end) break; &#125; cout &lt;&lt; maxNum &lt;&lt; "\n"; for(int i=0;i&lt;factors.size();i++)&#123; if(i!=0) cout &lt;&lt;"*"; cout &lt;&lt; factors[i]; &#125; return 0;&#125; 1097 Deduplication on a Linked List题目1097 Deduplication on a Linked List （25 分）Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤10^5​​ ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the position of the node, Key is an integer of which absolute value is no more than 10^4​, and Next is the position of the next node. Output Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:00100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854Sample Output:00100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 思路删除一个链表中绝对值相同的节点，只保留第一个。简单的链表删除，删除之后把删掉的节点记录在lastDelete中，然后删除下一个节点的时候，把lastdelete指向这个被删除的节点。最后把lastDelete指向-1。一开始输出的时候忘了把next也要填充到5位，而示例的输入输出又刚好next都是五位的……在这个坑爹的问题上卡了好久。为什么PAT的输入输出总是这么的让我崩溃。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Node&#123; int value; int next;&#125;;Node List[100010];set&lt;int&gt; s;int lastDelete = -1;int firstDelete = -1;void output(int root)&#123; int temp = root; while(temp!=-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; temp &lt;&lt; " " &lt;&lt; List[temp].value &lt;&lt; " " ; if(List[temp].next!=-1)&#123; cout.width(5); cout.fill('0'); &#125; cout &lt;&lt; List[temp].next &lt;&lt; "\n"; temp = List[temp].next; &#125;&#125;int main()&#123; int N,start; cin &gt;&gt; start &gt;&gt; N; int pos; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; pos; cin &gt;&gt; List[pos].value; cin &gt;&gt; List[pos].next; &#125; int pre = start; s.insert(abs(List[start].value)); while(List[pre].next!=-1)&#123; int now = List[pre].next; //无需删除，继续查找 if(s.count(abs(List[now].value))==0) &#123; s.insert(abs(List[now].value)); pre = now; &#125;else&#123;//删除节点// cout &lt;&lt; "delete: " &lt;&lt;now &lt;&lt; endl; List[pre].next = List[now].next; if(lastDelete==-1) &#123; firstDelete = now; &#125; else&#123; List[lastDelete].next = now; &#125; lastDelete = now; &#125; &#125; List[lastDelete].next = -1; output(start); output(firstDelete); return 0;&#125; 1098 Insertion or Heap Sort题目1098 Insertion or Heap Sort （25 分）According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification:For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0Sample Output 1:Insertion Sort1 2 3 5 7 8 9 4 6 0Sample Input 2:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9Sample Output 2:Heap Sort5 4 3 1 0 2 6 7 8 9 思路给出一个序列，及排序到一半的序列，判断到底是插入排序还是堆排序，然后再进行下一步。主要考察对插入排序及堆排序的熟悉程度。因为插入排序比较好写，所以就先一步一步的执行插入排序，和给定的序列进行比较，相同说明是插入排序，如果排序完成还不同说明是堆排序。判断出堆排序后，因为堆排序pop的每一个数都是堆中的最大值，所以堆排序序列后面的都是最大值，和之前插入排序已经排好的队列进行比较，就能找到排序进行到哪一步了，再进行一步排序就好。为了方便插入排序的比较和堆排序的下标运算，数组存放从1开始，0的值设为-1坐标标兵。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;int ori[110] = &#123;-1&#125;;int ins[110] = &#123;-1&#125;;int sorted[110] = &#123;-1&#125;;int N;//将第n个元素插入到前n-1个元素中合适的位置void Insertion(int arr[],int n)&#123; for(int i = n-1;i&gt;=0;i--)&#123; if(arr[n]&gt;arr[i])&#123; int temp = arr[n]; for(int j=n;j&gt;i+1;j--)&#123; arr[j] = arr[j-1]; &#125; arr[i+1] = temp; break; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N; for(int i=1;i&lt;=N;i++) &#123;cin &gt;&gt;ori[i];ins[i] = ori[i];&#125; for(int i=1;i&lt;=N;i++) cin &gt;&gt; sorted[i]; bool same; for(int j=2;j&lt;=N;j++)&#123; same = true; Insertion(ins,j);// for(int i=1;i&lt;=N;i++) cout &lt;&lt; ins[i] &lt;&lt; " ";// cout &lt;&lt; endl; for(int i=1;i&lt;=N;i++)&#123; if(ins[i]!=sorted[i])&#123; same = false; break; &#125; &#125; if(same)&#123; cout &lt;&lt; "Insertion Sort\n"; Insertion(ins,j+1); for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; ins[i]; &#125; return 0; &#125; &#125; int flag = N; for(;flag&gt;=1;flag--)&#123; if(sorted[flag]!=ins[flag]) break; &#125; int tem = sorted[flag]; sorted[flag] = sorted[1]; int prt = 1; while(prt*2&lt;flag)&#123; int chd = (prt*2+1==flag||sorted[prt*2]&gt;sorted[prt*2+1])?prt*2:prt*2+1; if(tem&gt;=sorted[chd]) break; sorted[prt] = sorted[chd];// cout &lt;&lt; prt &lt;&lt; " " &lt;&lt; chd &lt;&lt; endl; prt = chd; &#125; sorted[prt] = tem; cout &lt;&lt; "Heap Sort\n"; for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; sorted[i]; &#125; return 0;&#125; 1099 Build A Binary Search Tree题目1099 Build A Binary Search Tree （30 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input:91 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42Sample Output:58 25 82 11 38 67 45 73 42 思路考察二叉树的操作。先用递归把各个节点的左右子树的数量算出来，再用递归把排序后的数字填入节点中。再用个队列层序遍历整棵树并输出。看了一下别人的答案发现，二叉搜索树的中序遍历原来就是按数值从小到大遍历一遍，那直接中序遍历填数值，层序遍历输出就好。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;struct Node&#123; int value; int left,right; int leftNum,rightNum;&#125;;Node Tree[110];int N;vector&lt;int&gt; v;int CalChildrenNum(int root)&#123; Tree[root].leftNum = Tree[root].left==-1?0:(CalChildrenNum(Tree[root].left)+1); Tree[root].rightNum = Tree[root].right==-1?0:(CalChildrenNum(Tree[root].right)+1);// cout &lt;&lt; "Children Number of " &lt;&lt; root &lt;&lt; " is" &lt;&lt; Tree[root].leftNum+Tree[root].rightNum &lt;&lt; endl; return Tree[root].leftNum+Tree[root].rightNum;&#125;void build(int root,int from)&#123; Tree[root].value = v[from + Tree[root].leftNum];// cout &lt;&lt; "root: " &lt;&lt; root &lt;&lt; " value:" &lt;&lt; Tree[root].value &lt;&lt; endl; if(Tree[root].left!=-1) build(Tree[root].left,from); if(Tree[root].right!=-1) build(Tree[root].right,from + Tree[root].leftNum+1);&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; Tree[i].left &gt;&gt; Tree[i].right; &#125; int tem; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; tem; v.push_back(tem); &#125; sort(v.begin(),v.end()); CalChildrenNum(0); build(0,0); queue&lt;int&gt; q; q.push(0); while(!q.empty())&#123; int p = q.front(); q.pop(); if(p!=0) cout &lt;&lt; " "; cout &lt;&lt; Tree[p].value; if(Tree[p].left!=-1) q.push(Tree[p].left); if(Tree[p].right!=-1) q.push(Tree[p].right); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fpost%2Ffirst_article%2F</url>
    <content type="text"><![CDATA[博客终于搭建完成了！经过千辛万苦（长达两天的努力），我的博客终于上线了！以后会在这里记录一些科研以及学习的心得。 让我先试着放张图片： 下面放一段代码12str = "Hello world!"print(str) 下面是一个表格 AND true false true true false false false false 1.hexo从零开始到搭建完整2.Hexo下的Markdown语法(GFM)写博客3.Hexo搭建的GitHub博客之优化大全4.Hexo 官网5.Next 使用文档]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
