<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PATè€ƒè¯•é¡ºåˆ©é€šè¿‡]]></title>
    <url>%2Fpost%2FPAT_EXAM%2F</url>
    <content type="text"><![CDATA[ä¸€å‘¨æ²¡åˆ·è¿‡é¢˜äº†ï¼ŒåŽå¤©å¼€é¢˜ç­”è¾©è¿˜åœ¨åšPPTï¼Œéƒ½ä¸å¤ªæƒ³æ¥è€ƒäº†ï¼Œæ²¡æƒ³åˆ°ç«Ÿç„¶æ»¡åˆ†é€šè¿‡ðŸ˜‹è¿˜å¥½æˆ‘æ¥äº†ã€‚è®°å½•ä¸€ä¸‹è¿™ä¸ªåŽ†å²æ€§çš„æ—¶åˆ»ã€‚ä¸€å¼€å§‹ç¬¬ä¸€é“é¢˜å°±æ²¡åšå‡ºæ¥ï¼Œçœ‹ç€æ•°é‡çº§è¿˜æŒºå¤§ï¼Œç”¨ç´ æ•°è¡¨çš„æ–¹å¼ï¼Œå‘çŽ°å»ºè¡¨çš„è¿‡ç¨‹å°±è€—æ—¶å·¨é•¿ï¼ŒåŽé¢ç›´æŽ¥å†™ä¸ªå‡½æ•°åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°ï¼Œå‘çŽ°è¿˜æ˜¯æœ‰é—®é¢˜ï¼Œçƒ¦ï¼Œè·³è¿‡å…ˆåšç¬¬äºŒé¢˜ã€‚ç¬¬äºŒé¢˜ä¸€çœ‹å°±å‘çŽ°å·¨éº»çƒ¦ï¼Œå†™èµ·æ¥æžœç„¶å·¨éº»çƒ¦ï¼ŒèŠ±äº†ä¸€ä¸ªå°æ—¶ï¼Œå†™äº†ä¼°è®¡æœ‰ä¸€ç™¾è¡Œï¼Œå‘çŽ°åªè¿‡äº†ç¬¬ä¸€ä¸ªcaseæ‹¿äº†15åˆ†ï¼Œå´©æºƒï¼Œä»”ç»†æ£€æŸ¥äº†ä¸€ä¸‹ï¼Œå‘çŽ°ä¸ªå°é”™è¯¯ï¼Œå¤šäº†1åˆ†ï¼Œåˆå‘çŽ°ä¸ªå°é”™è¯¯ï¼Œåˆå¤šäº†2åˆ†ï¼Œçƒ¦ï¼ŒæŽ¥ç€è·³ã€‚çœ‹äº†ä¸€ä¸‹ç¬¬äºŒé¢˜çš„é€šè¿‡çŽ‡å·¨ä½Žï¼Œåªæœ‰ç™¾åˆ†ä¹‹ä¸‰å››çš„æ ·å­ã€‚æƒ³åˆ°ä¸€ä¸ªå¤šå°æ—¶è¿‡åŽ»äº†ï¼Œåªæ‹¿äº†åå‡ åˆ†ï¼Œå‡‰å‡‰ã€‚ç¬¬ä¸‰é¢˜ï¼Œå°±æ˜¯ä¸ªç®€å•çš„å›¾çš„éåŽ†ï¼Œç›´æŽ¥é€’å½’DFSåšçš„ï¼Œä¸€æ¬¡ACã€‚ç¬¬å››é¢˜ï¼Œæ ‘çš„DFSï¼Œè¾“å‡ºåˆ°å„ä¸ªå¶èŠ‚ç‚¹çš„è·¯å¾„ï¼Œç„¶åŽé¡ºä¾¿åˆ¤æ–­ä¸€ä¸‹æ˜¯ä¸æ˜¯å †ã€‚ä¹Ÿæ˜¯è¶…ç®€å•çš„é¢˜ç›®ï¼Œæ¯«æ— åŽ‹åŠ›çš„ACäº†ã€‚å›žåˆ°ç¬¬ä¸€é¢˜ï¼Œé‡æ–°å†™ã€‚ç›´æŽ¥å†™ä¸ªå‡½æ•°åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°ï¼Œç„¶åŽé€ä¸€åˆ¤æ–­å°±å¥½ï¼Œå¿˜äº†è¾“å‡ºå‰å¯¼0é”™äº†ä¸¤ä¸ªcaseï¼Œæ”¹ä¸€ä¸‹å°±é€šè¿‡äº†ã€‚çŽ°åœ¨åªå‰©ä¸‹äº†å·¨å¤æ‚ç¬¬äºŒé¢˜ï¼Œçœ‹äº†ä¸€ä¸‹æŽ’åï¼Œä¹åå…­åˆ†æŽ’åœ¨äº”åå‡ ï¼Œå‰é¢åŸºæœ¬éƒ½æ˜¯æ»¡åˆ†çš„äº†ã€‚ç¬¬äºŒé¢˜é€šè¿‡çš„ä¸€å…±ä¹Ÿå°±äº”åå‡ ä¸ªäººï¼Œè¿˜å‰©ä¸€ä¸ªå°æ—¶ï¼Œå¿ƒé‡Œè¿˜æ˜¯æœ‰ç‚¹æ…Œçš„ã€‚æ”¹äº†å‡ ä¸ªå¯èƒ½çš„è¾“å‡ºæ ¼å¼çš„é—®é¢˜ï¼Œå‘çŽ°æ²¡ç”¨ã€‚å†ä¸€çœ‹ï¼ŒåŽŸæ¥æ¯”è¾ƒçš„å‡½æ•°ç”±äºŽç»“æž„ä½“çš„å­—æ®µå¤ªå¤šæ¼æ¯”è¾ƒäº†ä¸€é¡¹ï¼Œèµ¶ç´§æ”¹æŽ‰ï¼Œæäº¤ï¼ŒACï¼çœ‹äº†ä¸€ä¸‹æŽ’åï¼Œæ²¡é”™ï¼Œ100åˆ†ï¼Œç¬¬ä¸€ï¼Œé‚£å°±æ²¡ä»€ä¹ˆå¥½è¯´çš„äº†æå‰å››åäº”åˆ†é’Ÿäº¤å·èµ°äºº~ PS.è€ƒå®Œåœ¨å¤–é¢å†»äº†ä¸€ä¸ªå°æ—¶ï¼Œç„¶åŽè¯´è¯ä¹¦è¿˜æœ‰é—®é¢˜ï¼Œç„¶åŽåˆç­‰äº†å¤§åŠä¸ªå°æ—¶ï¼Œå¿æ— å¯å¿çš„èµ°äº†â€¦â€¦è€ƒå®Œéƒ½ä¸è®©æ‹¿ä¸ªè¯ä¹¦è£…ä¸ªé€¼çœŸæ˜¯ä¸çˆ½ã€‚PS2.ç­‰çœŸé¢˜æ”¾å‡ºæ¥äº†å†è¡¥å……ä¸€ä¸‹ä»£ç ]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1104~1107è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1104_1107%2F</url>
    <content type="text"><![CDATA[1104 Sum of Number Segmentsé¢˜ç›®1104 Sum of Number Segments ï¼ˆ20 åˆ†ï¼‰Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4). Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than 10^â€‹5â€‹ . The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space. Output Specification:For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places. Sample Input:40.1 0.2 0.3 0.4Sample Output:5.00 æ€è·¯å…ˆæ˜¯æš´åŠ›ç®—äº†ä¸€ä¸‹ï¼Œæžœç„¶æœ€åŽä¸¤ä¸ªç‚¹è¶…æ—¶äº†ï¼Œç»è¿‡åå‡ åˆ†é’Ÿçš„æŽ¨å¯¼ç»ˆäºŽæŠŠç¬¬iä¸ªå…ƒç´ åœ¨é•¿ä¸ºnçš„æ‰€æœ‰å­åºåˆ—å’Œä¸­å‡ºçŽ°çš„æ¬¡æ•°(i+1)(n-i)ç»™æŽ¨å¯¼å‡ºæ¥äº†ã€‚ç»“æžœæœ€åŽä¸¤ä¸ªç‚¹ç«Ÿç„¶ç­”æ¡ˆé”™è¯¯ï¼Œæ£€æŸ¥äº†åŠå¤©ä¹Ÿæ²¡å‘çŽ°é—®é¢˜ï¼Œç”¨çš„æ˜¯doubleä¹Ÿä¸å¯èƒ½æº¢å‡ºå•Šâ€¦â€¦ä¸Šç½‘æŸ¥äº†ä¸€ä¸‹åˆ«çš„ä»£ç ï¼Œå‘çŽ°åŽŸæ¥æ˜¯(i+1)(n-i)ä¼šæº¢å‡ºâ€¦â€¦è€Œæˆ‘ç®—çš„æ—¶å€™æ˜¯å…ˆç®—çš„(i+1)(n-i)ï¼Œç„¶åŽå†ä¹˜ä»¥è¯¥å…ƒç´ çš„å€¼ã€‚æ‰€ä»¥æŠŠä»£ç ä»ŽSum+= (i+1)*(N-i)*a[i]æ”¹æˆSum+= a[i]*(i+1)*(N-i)å°±å¥½äº†ã€‚ è€—æ—¶ï¼š42min ä»£ç 123456789101112131415161718#include &lt;iostream&gt;using namespace std;double a[100000+10];int main()&#123; int N; scanf("%d",&amp;N); double Sum = 0; for(int i=0;i&lt;N;i++)&#123; scanf("%lf",&amp;a[i]); Sum+= a[i]*(i+1)*(N-i) ; &#125; printf("%.2f", Sum); return 0;&#125; 1105 Spiral Matrixé¢˜ç›®1105 Spiral Matrix ï¼ˆ25 åˆ†ï¼‰This time your job is to fill a sequence of N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m rows and n columns, where m and n satisfy the following: mÃ—n must be equal to N; mâ‰¥n; and mâˆ’n is the minimum of all the possible values. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N. Then the next line contains N positive integers to be filled into the spiral matrix. All the numbers are no more than 10^4. The numbers in a line are separated by spaces. Output Specification:For each test case, output the resulting matrix in m lines, each contains n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:1237 76 20 98 76 42 53 95 60 81 58 93Sample Output:98 95 9342 37 8153 20 7658 60 76 æ€è·¯æ²¿ç€èžºæ—‹çš„æ–¹å¼ä»Žå¤§åˆ°å°å¡«å……ä¸€ä¸ªçŸ©é˜µã€‚è®¾ç½®å››ä¸ªçŠ¶æ€ï¼Œåˆ†åˆ«æ˜¯å‘å³ã€å‘ä¸‹ã€å‘å·¦å’Œå‘ä¸Šï¼Œä¸€ä¸ªæ–¹å‘å¡«å……åˆ°æ— æ³•å¡«å……å°±åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ã€‚ä»£ç çœ‹èµ·æ¥æœ‰ç‚¹å†—ä½™ï¼Œä½†æ˜¯å†™èµ·æ¥è¿˜æ˜¯å¾ˆå¿«çš„ã€‚è€—æ—¶ï¼š23min12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;int mar[10000][10000];int num[10000];int getn(int N)&#123; int sq = (int)sqrt(N*1.0); for(;sq&gt;0;sq--)&#123; if(N%sq==0) return sq; &#125; return 1;&#125;int main()&#123; int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; num[i]; sort(num,num+N); int n=getn(N); int m = N/n; int pos = N-1; int i = 0,j = 0; int state = 0; while(N&gt;0)&#123; mar[i][j] = num[pos--]; if(pos==-1) break; while(true)&#123; if(state%4==0)&#123; if(i+1&lt;n&amp;&amp;mar[i+1][j]==0) &#123; i++; break; &#125; else state++; &#125; else if(state%4==1)&#123; if(j+1&lt;m&amp;&amp;mar[i][j+1]==0) &#123; j++; break; &#125; else state++; &#125; else if(state%4==2)&#123; if(i-1&gt;=0&amp;&amp;mar[i-1][j]==0) &#123; i--; break; &#125; else state++; &#125; else if(state%4==3)&#123; if(j-1&gt;=0&amp;&amp;mar[i][j-1]==0) &#123; j--; break; &#125; else state++; &#125; &#125; &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(j!=0) cout &lt;&lt; " "; cout &lt;&lt; mar[j][i]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125; 1106 Lowest Price in Supply Chainé¢˜ç›®1106 Lowest Price in Supply Chain ï¼ˆ25 åˆ†ï¼‰A supply chain is a network of retailersï¼ˆé›¶å”®å•†ï¼‰, distributorsï¼ˆç»é”€å•†ï¼‰, and suppliersï¼ˆä¾›åº”å•†ï¼‰â€“ everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from oneâ€™s supplier in a price P and sell or distribute them in a price that is r% higher than P. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers. Input Specification:Each input file contains one test case. For each case, The first line contains three positive numbers: N (â‰¤10^5), the total number of the members in the supply chain (and hence their IDâ€™s are numbered from 0 to Nâˆ’1, and the root supplierâ€™s ID is 0); P, the price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then N lines follow, each describes a distributor or retailer in the following format: $K_i$ ID[1] ID[2] â€¦ ID[$K_i$] where in the i-th line, Ki is the total number of distributors or retailers who receive products from supplier i, and is then followed by the IDâ€™s of these distributors or retailers. $K_j$ being 0 means that the j-th member is a retailer. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceed 10â€‹10â€‹â€‹ . Sample Input:10 1.80 1.003 2 3 51 91 41 702 6 11 8000Sample Output:1.8362 2 æ€è·¯è¿™é“é¢˜å’ŒPAT-A-1079å¾ˆç›¸ä¼¼ï¼Œè§£æ³•ä¹Ÿå¾ˆç›¸ä¼¼ï¼Œå°±æ˜¯æ ‘çš„éåŽ†ï¼Œè¿™é‡Œä¸ºäº†æ–¹ä¾¿ç›´æŽ¥ç”¨çš„DFSï¼Œç„¶åŽå¯¹æ¯ä¸ªå¶å­èŠ‚ç‚¹åˆ¤æ–­ä¸€ä¸‹ä»·æ ¼å°±å¥½ã€‚è¿™é‡Œè¿˜å¯ä»¥é€šè¿‡å½“å‰ä»·æ ¼æ˜¯å¦å·²ç»è¶…è¿‡æœ€å°çš„ä»·æ ¼æ¥åšä¸ªå‰ªæžã€‚è€—æ—¶ï¼š13min ä»£ç 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int N;double P,r;vector&lt;int&gt; Graph[100000];double minPrice = 1e11;int minNum;void DFS(int root,double price)&#123; if(Graph[root].size()==0)&#123; if(price &lt; minPrice)&#123; minPrice = price; minNum = 1; &#125; else if(price == minPrice) minNum++; return; &#125; for(int i=0;i&lt;Graph[root].size();i++) DFS(Graph[root][i],price*(1+r/100.));&#125;int main()&#123; cin &gt;&gt; N &gt;&gt;P &gt;&gt;r; int k,next; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; k; for(int j=0;j&lt;k;j++)&#123; cin &gt;&gt; next; Graph[i].push_back(next); &#125; &#125; DFS(0,P); printf("%.4f %d",minPrice,minNum); return 0;&#125; 1107 Social Clustersé¢˜ç›® æ€è·¯ç®€å•çš„å¹¶æŸ¥é›†ï¼Œæ ¹èŠ‚ç‚¹ç”¨è´Ÿæ•°è¡¨ç¤ºï¼Œå…¶ç»å¯¹å€¼ä»£è¡¨æœ¬é›†åˆçš„äººæ•°ï¼Œåˆå¹¶çš„æ—¶å€™äººæ•°ä¹Ÿè¦ç›¸åŠ ã€‚æŽ’ä¸ªåºå†è¾“å‡ºå°±å¥½ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int father[1010];void Union(int a,int b)&#123; while(father[a]&gt;0) a = father[a]; while(father[b]&gt;0) b = father[b]; if(a!=b) &#123; father[a] += father[b]; father[b] = a; &#125;&#125;vector&lt;int&gt; vec;int main()&#123; int N,K; int first; char c; int h; cin &gt;&gt;N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; K &gt;&gt; c; cin &gt;&gt; first; for(int j=1;j&lt;K;j++)&#123; cin &gt;&gt; h; Union(first,h); &#125; while(father[first]&gt;0) first = father[first]; father[first]--; &#125; for(int i=1;i&lt;=1000;i++) if(father[i]&lt;0) vec.push_back(father[i]); sort(vec.begin(),vec.end()); cout &lt;&lt; vec.size() &lt;&lt; "\n"; for(int i=0;i&lt;vec.size();i++) &#123; if(i!=0) cout &lt;&lt; " "; cout &lt;&lt; -vec[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1085è§£é¢˜æŠ¥å‘Šï¼ˆäºŒåˆ†æ³•ï¼‰]]></title>
    <url>%2Fpost%2FPAT_1085%2F</url>
    <content type="text"><![CDATA[1085 Perfect Sequenceé¢˜ç›®1085 Perfect Sequence ï¼ˆ25 åˆ†ï¼‰Given a sequence of positive integers and another positive integer p. The sequence is said to be a perfect sequence if Mâ‰¤mÃ—p where M and m are the maximum and minimum numbers in the sequence, respectively. Now given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence. Input Specification:Each input file contains one test case. For each case, the first line contains two positive integers N and p, where N (â‰¤10^5) is the number of integers in the sequence, and p (â‰¤10^9 ) is the parameter. In the second line there are N positive integers, each is no greater than 10^9â€‹ . Output Specification:For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence. Sample Input:10 82 3 20 4 5 1 6 7 8 9Sample Output:8 æ€è·¯é¦–å…ˆæ˜¯æƒ³åˆ°å…ˆæŽ’ä¸ªåºã€‚æŽ’å®Œåºæƒ³äº†ä¸€ä¸‹åŠ¨æ€è§„åˆ’æ²¡æ³•åšï¼Œå¦‚æžœç›´æŽ¥æš´åŠ›æœç´¢ï¼Œéœ€è¦O(N2)çš„æ—¶é—´å¤æ‚åº¦ï¼Œå¯¹äºŽN~10^5æ¥è¯´ä¼°è®¡æ˜¯è¿‡ä¸äº†çš„ï¼Œé‚£å°±äºŒåˆ†æ³•å§ã€‚å¯¹äºŽæ¯ä¸ªåºåˆ—ä¸­çš„æœ€å°å€¼ï¼Œé€šè¿‡äºŒåˆ†æ³•æ¥æ‰¾åˆ°ä½¿åºåˆ—æœ€é•¿çš„æœ€å¤§å€¼ã€‚äºŒåˆ†æ³•å¤„ç†çš„æ—¶å€™ï¼Œè€ƒè™‘åˆ°åºåˆ—ä¸­å¯èƒ½ä¼šæœ‰ç›¸åŒçš„å…ƒç´ ï¼Œè¦ä½¿åºåˆ—æœ€é•¿ï¼Œæ‰€ä»¥vec[mid] ==vec[i]*pçš„æƒ…å†µéœ€è¦ç»§ç»­å‘å³æœç´¢ï¼Œè¿™æ ·å¾—åˆ°çš„å°±æ˜¯ä¸€ä¸²ç›¸åŒæ•°å­—ä¸­æœ€åŽä¸€ä¸ªæ•°å­—å³è¾¹çš„ä½ç½®ã€‚æ‰€ä»¥rightåˆå§‹åŒ–çš„æ—¶å€™è®¾ç½®ä¸ºvec.size()è€Œä¸æ˜¯vec.size()-1ã€‚è¾“å…¥ï¼š10 81 1 2 3 4 5 6 7 8 8è¾“å‡ºï¼š10 ä»£ç 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; vec;int main()&#123; long long N,p; cin &gt;&gt; N &gt;&gt; p; vec.resize(N); for(int i=0;i&lt;N;i++) cin &gt;&gt; vec[i]; sort(vec.begin(),vec.end()); int maxL = 0; for(int i=0;i&lt;vec.size();i++)&#123; int left = i,right = vec.size(); int mid; while(left&lt;right)&#123; mid = (left+right)/2; if(vec[mid] &gt;vec[i]*p) &#123; right = mid-1; &#125; else left = mid+1; &#125; if(left-i&gt;maxL) &#123; maxL = left-i; &#125; &#125; cout &lt;&lt; maxL; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1074è§£é¢˜æŠ¥å‘Šï¼ˆæ¨¡æ‹Ÿé“¾è¡¨ï¼‰]]></title>
    <url>%2Fpost%2FPAT_1074%2F</url>
    <content type="text"><![CDATA[1074 Reversing Linked Listé¢˜ç›®1074 Reversing Linked List ï¼ˆ25 åˆ†ï¼‰Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1â†’2â†’3â†’4â†’5â†’6, if K=3, then you must output 3â†’2â†’1â†’6â†’5â†’4; if K=4, you must output 4â†’3â†’2â†’1â†’5â†’6. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (â‰¤10^5) which is the total number of nodes, and a positive K (â‰¤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N lines follow, each describes a node in the format: Address Data Nextwhere Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:00100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218Sample Output:00000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 æ€è·¯ä¸€å¼€å§‹ç›´æŽ¥å½“ä½œé“¾è¡¨æ¥å¤„ç†ï¼Œé€»è¾‘ç›¸å½“å¤æ‚ï¼ŒæŒ‡é’ˆé£žæ¥é£žåŽ»çš„ç®€ç›´è¦å´©æºƒï¼Œå‹‰å¼ºACäº†ã€‚çœ‹äº†ä¸€ä¸‹åˆ«äººçš„ç­”æ¡ˆï¼ŒåŽŸæ¥ç›´æŽ¥ç”¨ä¸€ä¸ªæ•°ç»„æ¥æ¨¡æ‹Ÿé“¾è¡¨å°±å¥½ï¼Œç‰ºç‰²äº†ç©ºé—´å¤æ‚åº¦ï¼Œä½†æ˜¯ä»£ç éžå¸¸çš„ç®€å•æ˜“æ‡‚ã€‚ ##ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//#include &lt;iostream&gt;//#include &lt;iomanip&gt;//using namespace std;//int Data[100000+10];//int Next[100000+10];//int Add[100000+10];//int main()//&#123;// int head,N,K;// cin &gt;&gt; head &gt;&gt; N &gt;&gt; K;// int add;// for(int i=0;i&lt;N;i++)&#123;// cin &gt;&gt; add;// cin &gt;&gt; Data[add] &gt;&gt; Next[add];// &#125;// Next[100000+5] = head;// if(K&gt;1)&#123;// int now = 100000+5;// while(true)&#123;//// cout &lt;&lt; "now: " &lt;&lt;now &lt;&lt; endl;// int k=0;// while(k&lt;=K+1)&#123;// Add[k] = now;//// cout &lt;&lt; "Add: " &lt;&lt; k &lt;&lt; " " &lt;&lt; Add[k] &lt;&lt; endl;// k++;// if(now==-1) break;// now = Next[now];// &#125;// if(k==K+2)&#123;// Next[Add[0]] = Add[K];// Next[Add[1]] = Add[K+1];// for(int i=2;i&lt;=K;i++)&#123;// Next[Add[i]] = Add[i-1];// &#125;// &#125;else break;// now = Add[1];// &#125;//// &#125;// int now = Next[100000+5];// while(now!=-1)&#123;// cout.width(5);cout.fill('0');// cout &lt;&lt; now &lt;&lt; " " &lt;&lt; Data[now] &lt;&lt; " ";// now = Next[now];// if(now!=-1)&#123; cout.width(5);cout.fill('0');&#125;// cout &lt;&lt; now &lt;&lt; "\n";// &#125;//// return 0;//&#125;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int Data[100000+10];int Next[100000+10];int Add[100000+10];int main()&#123; int head,N,K; cin &gt;&gt; head &gt;&gt; N &gt;&gt; K; int address; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt;address; cin &gt;&gt; Data[address] &gt;&gt; Next[address]; &#125; int num = 0; while(head!=-1)&#123; Add[num++] = head; head = Next[head]; &#125; for(int i=0;i&lt;num/K;i++)&#123; reverse(Add+K*i,Add+K*i+K); &#125; for(int i=0;i&lt;num-1;i++)&#123; printf("%05d %d %05d\n",Add[i],Data[Add[i]],Add[i+1]);// cout &lt;&lt; Add[i] &lt;&lt; " " &lt;&lt; Data[Add[i]] &lt;&lt; " " &lt;&lt; Add[i+1]&lt;&lt; "\n"; &#125; printf("%05d %d %d\n",Add[num-1],Data[Add[num-1]],-1); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1072è§£é¢˜æŠ¥å‘Šï¼ˆå›¾ï¼ŒDijkstraç®—æ³•ï¼‰]]></title>
    <url>%2Fpost%2FPAT_1072%2F</url>
    <content type="text"><![CDATA[1072 Gas Stationé¢˜ç›®1072 Gas Station ï¼ˆ30 åˆ†ï¼‰A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range. Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number. Input Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers: N (â‰¤10^3), the total number of houses; M (â‰¤10), the total number of the candidate locations for the gas stations; K (â‰¤10^4), the number of roads connecting the houses and the gas stations; and DS, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM. Then K lines follow, each describes a road in the format P1 P2 Distwhere P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road. Output Specification:For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution. Sample Input 1:4 3 11 51 2 21 4 21 G1 41 G2 32 3 22 G2 13 4 23 G3 24 G1 3G2 G1 1G3 G2 2Sample Output 1:G12.0 3.3Sample Input 2:2 1 2 101 G1 92 G1 20Sample Output 2:No Solution æ€è·¯é¢˜ç›®ç»™å‡ºä¸€ä¸ªå›¾ï¼Œå›¾ä¸­åŒ…æ‹¬Nä¸ªæˆ¿å­èŠ‚ç‚¹å’ŒMä¸ªå€™é€‰åŠ æ²¹ç«™èŠ‚ç‚¹ï¼Œéœ€è¦æ‰¾åˆ°ä¸€ä¸ªåŠ æ²¹ç«™æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š1.åˆ°å„ä¸ªæˆ¿å­çš„æœ€çŸ­è·ç¦»æœ€å¤§2.å¦‚æžœæ»¡è¶³1çš„ä¸æ­¢ä¸€ä¸ªï¼Œåˆ°å„ä¸ªæˆ¿å­çš„å¹³å‡è·ç¦»æœ€å°3.å¦‚æžœæ»¡è¶³1ï¼Œ2çš„ä¸æ­¢ä¸€ä¸ªï¼Œåºå·æœ€å°è¿™å…¶å®žæ˜¯ä¸ªå¤šæºæœ€çŸ­è·¯å¾„ï¼Œä½†æ˜¯ç”±äºŽMæ¯”è¾ƒå°ï¼Œç›´æŽ¥è°ƒç”¨Mæ¬¡Dijkstraç®—æ³•å°±å¥½ï¼Œæ¯æ¬¡è°ƒç”¨å®Œè®¡ç®—ä¸€ä¸‹åˆ°å„ä¸ªæˆ¿å­çš„æœ€çŸ­è·ç¦»ã€å¹³å‡è·ç¦»ç­‰ä¿¡æ¯ï¼Œæœ€åŽæ‰¾åˆ°æœ€ä¼˜è§£ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3fffffff;const int MAXV = 1020;int N,M,K,D;int Graph[MAXV][MAXV];bool collected[MAXV];int dist[MAXV];int FindMinVertex()&#123; int minDist = INF,minV = -1; for(int i=1;i&lt;=N+M;i++)&#123; if(!collected[i]&amp;&amp;dist[i]&lt;minDist)&#123; minDist = dist[i]; minV = i; &#125; &#125;// cout &lt;&lt; "Find: " &lt;&lt; minV &lt;&lt; endl; return minV;&#125;void Dijkstra(int source)&#123; fill(dist+1,dist+N+M+1,INF); fill(collected+1,collected+N+M+1,false); dist[source] = 0; while(true)&#123; int minV = FindMinVertex(); if(minV==-1) break; collected[minV] = true; for(int i=1;i&lt;=N+M;i++)&#123; if(!collected[i]&amp;&amp;dist[minV] + Graph[minV][i]&lt;dist[i])&#123; dist[i] = dist[minV] + Graph[minV][i];// cout &lt;&lt;"dist: " &lt;&lt; i &lt;&lt; " " &lt;&lt; dist[i] &lt;&lt; " " &lt;&lt;Graph[minV][i] &lt;&lt;endl; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M&gt;&gt; K &gt;&gt; D; fill(Graph[0],Graph[0]+MAXV*MAXV,INF); string P1,P2; int p1,p2; int Dist; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; P1 &gt;&gt; P2 &gt;&gt; Dist; if(P1[0]=='G') p1 = stoi(P1.substr(1))+N; else p1 = stoi(P1); if(P2[0]=='G') p2 = stoi(P2.substr(1))+N; else p2 = stoi(P2); Graph[p1][p2] = min(Graph[p1][p2],Dist); Graph[p2][p1] = Graph[p1][p2]; &#125; int bestV = -1; double average = INF; double minimum = -1; for(int i=N+1;i&lt;=N+M;i++)&#123; Dijkstra(i); double sum=0; double mini = INF; int j; for(j=1;j&lt;=N;j++)&#123; if(dist[j]&gt;D) break; sum+=dist[j]; if(dist[j]&lt;mini) mini = dist[j]; &#125; if(j!=N+1) continue; if(mini &gt; minimum||mini==minimum&amp;&amp;sum/N&lt;average)&#123; average = sum/N; minimum = mini; bestV = i-N; &#125; &#125; cout.setf(ios::fixed); cout.precision(1); if(bestV!=-1)&#123; cout &lt;&lt; "G" &lt;&lt; bestV &lt;&lt; "\n"; cout &lt;&lt; minimum+eps &lt;&lt; " " &lt;&lt; average+eps; &#125; else&#123; cout &lt;&lt; "No Solution"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1067è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1067%2F</url>
    <content type="text"><![CDATA[1067 Sort with Swap(0, i)é¢˜ç›®1067 Sort with Swap(0, i) ï¼ˆ25 åˆ†ï¼‰Given any permutation of the numbers {0, 1, 2,â€¦, Nâˆ’1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: Swap(0, 1) =&gt; {4, 1, 2, 0, 3}Swap(0, 3) =&gt; {4, 1, 2, 3, 0}Swap(0, 4) =&gt; {0, 1, 2, 3, 4}Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers. Input Specification:Each input file contains one test case, which gives a positive N (â‰¤10^5) followed by a permutation sequence of {0, 1, â€¦, Nâˆ’1}. All the numbers in a line are separated by a space. Output Specification:For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input:103 5 7 2 6 4 9 0 8 1Sample Output:9 æ€è·¯è¡¨æŽ’åº-ç‰©ç†æŽ’åºçš„é—®é¢˜ã€‚çœ‹äº†å§¥å§¥çš„è¯¾åˆå›žå¿†äº†ä¸€ä¸‹è¡¨æŽ’åºã€‚é¢˜ç›®è¦æ±‚é€šè¿‡â€œä¸Ž0äº¤æ¢â€è¿™ä¸ªæ“ä½œå¯¹åºåˆ—è¿›è¡ŒæŽ’åºã€‚é¦–å…ˆé€šè¿‡ç‰©ç†æŽ’åºçš„æ–¹æ³•ï¼Œçœ‹ä¸€ä¸‹åºåˆ—ä¸­å­˜åœ¨å‡ ä¸ªçŽ¯ï¼ˆåªæœ‰ä¸€ä¸ªå…ƒç´ çš„çŽ¯ï¼Œå³ä¸éœ€ç§»åŠ¨çš„å…ƒç´ ä¸ç”¨ç®¡ï¼‰ï¼Œç„¶åŽå¯ä»¥å‘çŽ°ï¼Œè®°ç¬¬iä¸ªçŽ¯ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸ºn_iï¼Œå¦‚æžœçŽ¯ä¸­å­˜åœ¨å…ƒç´ 0ï¼Œé‚£ä¹ˆåªéœ€è¦è¿›è¡Œn_i-1æ¬¡äº¤æ¢ï¼Œå¦‚æžœä¸å­˜åœ¨å…ƒç´ 0ï¼Œéœ€è¦å°†çŽ¯ä¸­çš„ä¸€ä¸ªå…ƒç´ ä¸Ž0è¿›è¡Œäº¤æ¢ï¼Œå¯¹å½¢æˆçš„æ–°çš„åŒ…å«0çš„çŽ¯å†è¿›è¡Œå¦‚ä¸Šæ‰€è¿°äº¤æ¢ï¼Œå³éœ€è¦n_i+1æ¬¡äº¤æ¢ã€‚æ‰€ä»¥åªéœ€è¦è®°å½•æ‰€æœ‰éœ€è¦äº¤æ¢çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œç„¶åŽæ¯å¤šä¸€ä¸ªä¸åŒ…å«0çš„çŽ¯ï¼Œéœ€è¦äº¤æ¢çš„æ€»æ•°éœ€è¦é¢å¤–åŠ 1ï¼Œå¦‚æžœæœ‰åŒ…å«0çš„çŽ¯ï¼Œé‚£ä¹ˆéœ€è¦äº¤æ¢çš„æ€»æ•°å°±é¢å¤–å‡1ã€‚å³å¯å¾—åˆ°ä»¥ä¸‹ä»£ç ï¼š ä»£ç 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int table[100000+10];int main()&#123; int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; table[i]; int n = 0; for(int i=0;i&lt;N;i++)&#123; if(table[i]!=i)&#123; if(i==0)n--; else n++; int j = i; while(table[j]!=j)&#123; n++;// cout &lt;&lt; j &lt;&lt; " " &lt;&lt; table[j]&lt;&lt; endl; int tmp = table[j]; table[j] = j; j = tmp; &#125; &#125; &#125; cout &lt;&lt; n; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1060è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1060%2F</url>
    <content type="text"><![CDATA[1060 Are They Equalé¢˜ç›®1060 Are They Equal ï¼ˆ25 åˆ†ï¼‰If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123Ã—10^5 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification:Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^â€‹100, and that its total digit number is less than 100. Output Specification:For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]â€¦d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1:3 12300 12358.9Sample Output 1:YES 0.12310^5Sample Input 2:3 120 128Sample Output 2:NO 0.12010^3 0.128*10^3 æ€è·¯é¢˜ç›®è¦æ±‚ä¸»è¦å°±æ˜¯ç»™å®šæœ‰æ•ˆæ•°å­—ï¼ŒæŠŠä¸€ä¸ªæµ®ç‚¹æ•°ç”¨ç§‘å­¦è®°æ•°æ³•è¡¨ç¤ºå‡ºæ¥ã€‚æ•°å­—æœ‰100ä½ï¼Œæ‰€ä»¥åŸºæœ¬åªèƒ½ç”¨å­—ç¬¦ä¸²æ¥è¡¨ç¤ºï¼Œå¹¶è¿›è¡Œå¤„ç†äº†ã€‚ç›´æŽ¥é€šè¿‡ä¸€æ¬¡æ‰«æï¼Œæ‰«æçš„è¿‡ç¨‹ä¸­æŠŠä½æ•°ç­‰ä¿¡æ¯ä¿å­˜ä¸‹æ¥ã€‚ç»†èŠ‚å¾ˆå¤šï¼Œå¾ˆå¤šå°å‘ã€‚å®¹æ˜“å‡ºé”™çš„è¾“å…¥åŒ…æ‹¬0.0001234, 0.00000ç­‰ã€‚to_string()å¯ä»¥æŠŠæ•°å­—è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¾ˆå¥½ç”¨ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;string chop(string s,int sigDigits)&#123; string ret = "0."; bool isPositive = s[0]!='-'; int digit = 0; bool afterPoint = false; bool firstZero = true; for(int i = 1-isPositive;i&lt;s.size();i++)&#123; if(firstZero&amp;&amp;s[i]=='0') &#123; if(afterPoint) digit--; continue; &#125; if(s[i] == '.') &#123; afterPoint = true; continue; &#125; firstZero = false; if(ret.size()&lt;sigDigits+2) ret.push_back(s[i]); if(!afterPoint) digit++; &#125; if(firstZero) digit = 0;//æ•°å­—ä¸º0åˆ™å°†ä½æ•°ç½®ä¸º0ï¼Œå¦åˆ™è¾“å…¥0.000ä¼šå‡ºé”™ while(ret.size()&lt;sigDigits+2) ret+="0"; ret+= "*10^" + to_string(digit); if(!isPositive) ret = "-" + ret; return ret;&#125;int main()&#123; int N; string A,B; string Ac,Bc; cin &gt;&gt; N &gt;&gt; A &gt;&gt; B; Ac = chop(A,N); Bc = chop(B,N); if(Ac==Bc) &#123; cout &lt;&lt; "YES " &lt;&lt; Ac; &#125; else &#123; cout &lt;&lt; "NO " &lt;&lt; Ac &lt;&lt; " " &lt;&lt; Bc; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1052è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1052%2F</url>
    <content type="text"><![CDATA[1052 Linked List Sortingé¢˜ç›®1052 Linked List Sorting ï¼ˆ25 åˆ†ï¼‰A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification:Each input file contains one test case. For each case, the first line contains a positive N (&lt;10^5 ) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by âˆ’1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the address of the node in memory, Key is an integer in [âˆ’10^â€‹5â€‹â€‹,10^â€‹5â€‹ ], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification:For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input:5 0000111111 100 -100001 0 2222233333 100000 1111112345 -1 3333322222 1000 12345Sample Output:5 1234512345 -1 0000100001 0 1111111111 100 2222222222 1000 3333333333 100000 -1 æ€è·¯ä¸€å¼€å§‹æ²¡è€ƒè™‘åˆ°é“¾è¡¨ä¸­è¿˜æœ‰æ— æ•ˆçš„æ•°æ®ï¼Œç›´æŽ¥æŠŠæ‰€æœ‰èŠ‚ç‚¹æŽ’åºï¼Œç„¶åŽæœ‰å‡ ä¸ªcaseè¿‡ä¸äº†ã€‚å…ˆä»Žå¤´å¼€å§‹ï¼Œæ²¿ç€nextçš„é¡ºåºè¯»ä¸€éï¼Œå­˜åˆ°æ•°ç»„é‡Œï¼Œç„¶åŽæŽ’ä¸ªåºå†è¾“å‡ºå°±å¥½ã€‚æ›´å°ç©ºé—´å¤æ‚åº¦çš„æ–¹æ³•æ˜¯åœ¨NodeåŠ ä¸€ä¸ªflagåˆ¤æ–­æ˜¯å¦è¯»å–ï¼Œåœ¨æŽ’åºçš„æ—¶å€™æŠŠæ— æ•ˆçš„èŠ‚ç‚¹æŽ’åˆ°æœ€åŽï¼Œå†è¾“å‡ºå‰é¢æœ‰æ•ˆçš„nä¸ªèŠ‚ç‚¹å³å¯ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Node&#123; int address,key,next; friend bool operator&lt;(Node n1,Node n2)&#123; return n1.key&lt;n2.key; &#125;&#125;;vector&lt;Node&gt; vN;Node aN[100000];int main()&#123; ios::sync_with_stdio(false); int N,st; cin &gt;&gt; N &gt;&gt; st; int address,key,next; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; address &gt;&gt; key &gt;&gt; next; aN[address] = Node&#123;address,key,next&#125;; &#125; while(st!=-1)&#123; vN.push_back(aN[st]); st = aN[st].next; &#125; sort(vN.begin(),vN.end()); cout &lt;&lt; vN.size() &lt;&lt; " "; if(vN.size()&gt;0)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[0].address &lt;&lt; "\n"; &#125; else&#123; cout &lt;&lt; "-1"; return 0; &#125; for(int i=0;i&lt;vN.size();i++)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[i].address &lt;&lt; " " &lt;&lt; vN[i].key &lt;&lt; " "; if(i!=vN.size()-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; vN[i+1].address; &#125; else cout &lt;&lt; "-1"; cout &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1045è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT-1045%2F</url>
    <content type="text"><![CDATA[1045 Favorite Color Stripeé¢˜ç›®1045 Favorite Color Stripe ï¼ˆ30 åˆ†ï¼‰Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Evaâ€™s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Evaâ€™s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (â‰¤200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (â‰¤200) followed by M Evaâ€™s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (â‰¤10^4) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line a separated by a space. Output Specification:For each test case, simply print in a line the maximum length of Evaâ€™s favorite stripe. Sample Input:65 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6Sample Output:7 æ€è·¯ç®—æ˜¯æˆ‘åšçš„ç¬¬äºŒé“åŠ¨æ€è§„åˆ’é¢˜ç›®ï¼Œæƒ³æ˜Žç™½äº†ä¹‹åŽè¿˜æ˜¯å¾ˆç®€å•çš„ï¼Œæˆ‘éƒ½ä¸æ•¢ç›¸ä¿¡è¿™ä¹ˆç®€å•ã€‚é¢˜ç›®ç±»ä¼¼æœ€é•¿å…¬å…±å­åºåˆ—ï¼Œä½†æ˜¯åºåˆ—aä¸­çš„å…ƒç´ å…è®¸å†åºåˆ—bä¸­é‡å¤å¤šæ¬¡ã€‚è®°dp[i][j]ä¸ºa[1]~a[i]ä¸Žb[1]~b[j]çš„æœ€é•¿å¯é‡å¤å…¬å…±å­åºåˆ—ï¼Œé‚£ä¹ˆæœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šå¦‚æžœa[i] = b[j], dp[i][j] = dp[i][j-1] +1ï¼Œå› ä¸ºa[i]å¯èƒ½åœ¨b[j]å‰å‡ºçŽ°è¿‡ï¼Œæ‰€ä»¥iä¸ç”¨å˜å¦‚æžœa[i] != b[j], dp[i][j] = max(dp[i-1][j],dp[i][j-1])è¾¹ç•Œæ¡ä»¶å³dp[i][0] = 0,dp[j][0] = 0ï¼Œè¿™ä¸ªæ¡ä»¶åœ¨åˆå§‹åŒ–dpçš„æ—¶å€™å·²ç»å®žçŽ°äº†ã€‚ ä»£ç 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int a[201];int b[10001];int dp[201][10001];int main()&#123; int N,L,M; cin &gt;&gt; N; cin &gt;&gt; M; for(int i=1;i&lt;=M;i++) cin &gt;&gt; a[i]; cin &gt;&gt; L; for(int i=1;i&lt;=L;i++) cin &gt;&gt; b[i]; int maxLen = 0; for(int i=1;i&lt;=M;i++)&#123; for(int j=1;j&lt;=L;j++)&#123; if(a[i]==b[j]) dp[i][j] = dp[i][j-1]+1; else dp[i][j] = max(dp[i][j-1],dp[i-1][j]); if(dp[i][j]&gt;maxLen) maxLen = dp[i][j]; &#125; &#125; cout &lt;&lt; maxLen; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1044è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT-1044%2F</url>
    <content type="text"><![CDATA[1044 Shopping in Marsé¢˜ç›®1044 Shopping in Mars ï¼ˆ25 åˆ†ï¼‰Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15).Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (â‰¤10^â€‹5â€‹â€‹ ), the total number of diamonds on the chain, and M (â‰¤10^8â€‹â€‹ ), the amount that the customer has to pay. Then the next line contains N positive numbers D1â€‹â€‹ â‹¯Dâ€‹Nâ€‹â€‹ (Dâ€‹iâ€‹â€‹ â‰¤10^â€‹3 for all i=1,â‹¯,N) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification:For each test case, print i-j in a line for each pair of i â‰¤ j such that Di + â€¦ + Dj = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i. If there is no solution, output i-j for pairs of i â‰¤ j such that Di + â€¦ + Dj &gt;M with (Di + â€¦ + Dj âˆ’M) minimized. Again all the solutions must be printed in increasing order of i. It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1:16 153 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13Sample Output 1:1-54-67-811-11Sample Input 2:5 132 4 5 7 9Sample Output 2:2-44-5 æ€è·¯å°†å‰iä¸ªæ•°çš„å’Œä¿å­˜åœ¨sumæ•°ç»„ä¸­ï¼Œç„¶åŽä»Žiåˆ°jçš„å’Œå°±æ˜¯sum[j]-sum[i]ã€‚ä¸€å¼€å§‹ç›´æŽ¥ä¸¤é‡å¾ªçŽ¯æ¥åšï¼ŒO(n^2)çš„å¤æ‚åº¦ï¼Œæžœç„¶ä¸¤ä¸ªcaseè¶…æ—¶äº†ã€‚æ”¹ç”¨äºŒåˆ†æŸ¥æ‰¾å°±é€šè¿‡äº†ã€‚æ³¨æ„äºŒåˆ†æŸ¥æ‰¾çš„å†™æ³•ï¼Œåœ¨æ‰¾ä¸åˆ°æ—¶è¿”å›žå¤§äºŽæŸ¥æ‰¾å€¼çš„ç¬¬ä¸€ä¸ªä½ç½®ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int dc[100010];long long sum[100010];int N,M;int Half(int i)&#123; int left = i; int right = N; int mid; while(left&lt;right)&#123;// cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; " right: " &lt;&lt;right &lt;&lt; endl; mid = (left+right)/2; if(sum[mid]-sum[i-1]&lt;M) left = mid+1; else if(sum[mid]-sum[i-1]&gt;M) right = mid; else return mid; &#125; return left;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M; for(int i=0;i&lt;N;i++) cin &gt;&gt; dc[i]; sum[0] = 0; for(int i=1;i&lt;=N;i++) sum[i] = sum[i-1] + dc[i-1];// for(int i=0;i&lt;=N;i++) cout &lt;&lt; sum[i] &lt;&lt;" ";// cout &lt;&lt; endl; vector&lt;int&gt; v; long long minMoney = 0x3fffffff; for(int i=1;i&lt;=N;i++)&#123; int tmp = Half(i);// cout &lt;&lt; "Half" &lt;&lt; i &lt;&lt; " " &lt;&lt; tmp &lt;&lt; endl; if(sum[tmp] - sum[i-1] &lt; M) continue; if(sum[tmp]-sum[i-1] &lt; minMoney)&#123; minMoney = sum[tmp]-sum[i-1];// cout &lt;&lt; "minMoney: " &lt;&lt; minMoney &lt;&lt; endl; v.clear(); v.push_back(i); v.push_back(tmp); &#125; else if(sum[tmp] - sum[i-1] == minMoney)&#123; v.push_back(i); v.push_back(tmp); &#125; &#125;// cout &lt;&lt; minMoney &lt;&lt; endl; for(int i=0;i&lt;v.size()/2;i++)&#123; cout &lt;&lt; v[2*i] &lt;&lt; "-" &lt;&lt; v[2*i+1] &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1043è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT-1043%2F</url>
    <content type="text"><![CDATA[1043 Is It a Binary Search Treeé¢˜ç›®1043 Is It a Binary Search Tree ï¼ˆ25 åˆ†ï¼‰A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key.The right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.Both the left and right subtrees must also be binary search trees.If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST. Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (â‰¤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:78 6 5 7 10 8 11Sample Output 1:YES5 7 6 8 11 10 8Sample Input 2:78 10 11 8 6 7 5Sample Output 2:YES11 8 10 7 5 6 8Sample Input 3:78 6 8 5 10 9 11Sample Output 3:NO æ€è·¯ä¸€å¼€å§‹åˆSBçš„ä»¥ä¸ºpreOrderæ˜¯å·¦ä¸­å³çš„è®¿é—®é¡ºåºï¼Œç»“æžœé¢˜ç›®éƒ½è¯»ä¸æ‡‚ã€‚è¯»æ‡‚é¢˜ç›®ä¹‹åŽï¼Œå°±å‡è®¾æ˜¯åºåˆ—æ˜¯BSTï¼Œç„¶åŽæ¥é€’å½’çš„å»ºç«‹è¿™æ£µæ ‘ã€‚é¦–å…ˆä»¥BSTï¼ˆéžé•œåƒï¼‰ï¼Œä»¥8 6 5 7 10 8 11ä¸ºä¾‹ï¼Œé¦–å…ˆç”±äºŽæ˜¯å…ˆåºéåŽ†ï¼Œ8å°±æ˜¯æ ¹ï¼Œå·¦å­æ ‘å°±æ˜¯å³è¾¹åºåˆ—6 5 7 10 8 11ä¸­å°äºŽæ ¹çš„éƒ¨åˆ†ï¼Œå³å­æ ‘å°±æ˜¯å¤§äºŽç­‰äºŽæ ¹çš„åºåˆ—ã€‚ç”¨iä»Žå·¦åˆ°å³çš„æ‰«æï¼Œåˆ°å¤§äºŽç­‰äºŽæ ¹çš„åœ°æ–¹åœä¸‹ï¼Œjä»Žåˆå¾€å·¦æ‰«æåˆ°å°äºŽæ ¹çš„åœ°æ–¹åœä¸‹ã€‚å¦‚æžœi+1=jï¼Œé‚£ä¹ˆç¬¦åˆBSTçš„æ¡ä»¶ï¼Œç»§ç»­é€’å½’çš„ç”Ÿæˆå·¦å­æ ‘å’Œå³å­æ ‘ï¼Œå¦åˆ™ä¸æ»¡è¶³BSTçš„æ¡ä»¶ï¼Œæ‰€æœ‰é€’å½’éƒ½ä¸­æ­¢ã€‚ä¸€å¼€å§‹åœ¨æ‰«æçš„æ—¶å€™æ²¡æœ‰åˆ¤æ–­æ‰«æçš„ç»ˆç‚¹ï¼Œå¯¼è‡´ä¸€ä¸å°å¿ƒå°±æ‰«æå‡ºäº†[from,to]çš„èŒƒå›´ï¼Œç”šè‡³å‡ºçŽ°æ®µé”™è¯¯ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;typedef struct Node *Tree;struct Node&#123; int value; Tree left,right;&#125;;int seq[1010];int N;bool isBST = true;bool first = true;Tree buildTree(int from,int to)&#123; if(!isBST) return NULL; if(from &gt; to) return NULL; if(from==to) return new Node&#123;seq[from],NULL,NULL&#125;; int i=from,j=to+1; while(seq[i+1]&lt;seq[from]&amp;&amp;i&lt;=to-1) i++; while(seq[j-1]&gt;=seq[from]&amp;&amp;j&gt;=from+2) j--; if(i+1==j)&#123; return new Node&#123;seq[from],buildTree(from+1,i),buildTree(j,to)&#125;; &#125; else&#123; isBST = false; return NULL; &#125;&#125;Tree buildTreeM(int from,int to)&#123; if(!isBST) return NULL; if(from &gt; to) return NULL; if(from==to) return new Node&#123;seq[from],NULL,NULL&#125;; int i=from,j=to+1; while(seq[i+1]&gt;=seq[from]&amp;&amp;i&lt;=to-1) i++; while(seq[j-1]&lt;seq[from]&amp;&amp;j&gt;=from+2) j--; if(i+1==j)&#123; return new Node&#123;seq[from],buildTreeM(from+1,i),buildTreeM(j,to)&#125;; &#125; else&#123; isBST = false; return NULL; &#125;&#125;void postOrder(Tree t)&#123; if(t-&gt;left) postOrder(t-&gt;left); if(t-&gt;right) postOrder(t-&gt;right); if(first) first = false; else cout &lt;&lt;" "; cout &lt;&lt; t-&gt;value;&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; seq[i]; &#125; if(N==0)&#123; cout &lt;&lt; "YES\n"; return 0; &#125; Tree t = buildTree(0,N-1); if(isBST)&#123; cout &lt;&lt; "YES\n"; postOrder(t); &#125; else &#123; isBST = true; t = buildTreeM(0,N-1); if(isBST)&#123; cout &lt;&lt; "YES\n"; postOrder(t); &#125; else&#123; cout &lt;&lt; "NO\n"; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1040è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT-1040%2F</url>
    <content type="text"><![CDATA[1040 Longest Symmetric Stringé¢˜ç›®1040 Longest Symmetric String ï¼ˆ25 åˆ†ï¼‰Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11. Input Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification:For each test case, simply print the maximum length in a line. Sample Input:Is PAT&amp;TAP symmetric?Sample Output:11 æ€è·¯ç¬¬ä¸€æ¬¡åšåŠ¨æ€è§„åˆ’çš„é¢˜ç›®â€¦â€¦å‚ç…§ã€Šç®—æ³•ç¬”è®°ã€‹ä¸­åŠ¨æ€è§„åˆ’çš„å†…å®¹ã€‚bool dp[i]jç”¨æ¥è®°å½•ä»Žiåˆ°jçš„å­ä¸²æ˜¯å¦ä¸ºå›žæ–‡å­—ç¬¦ä¸²ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿå¾ˆç®€å•ï¼šdp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == s[j]ã€‚é—®é¢˜æ˜¯å¦‚ä½•ä»Žè¾¹ç•Œå‡ºå‘è®¡ç®—æ•´ä¸ªæ•°ç»„ï¼Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯å…ˆåˆå§‹åŒ–é•¿åº¦ä¸º1å’Œ2çš„å­ä¸²ï¼Œç„¶åŽä»Ž3å¼€å§‹è®¡ç®—ï¼Œä¸€ç›´è®¡ç®—å®Œæ•´ä¸ªå­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²é•¿åº¦ä¸º1çš„æ—¶å€™ï¼Œåˆå§‹åŒ–é•¿åº¦ä¸º2çš„å­—ä¸²ä¼šè¯»å–åˆ°â€™\0â€™å› è€Œä¸ä¼šäº§ç”Ÿé”™è¯¯ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;bool dp[1010][1010];int main()&#123; int maxLen = 1; char s[1010]; cin.getline(s,1010); int len = 0; while(s[len++]!='\0'); for(int i=0;i&lt;len;i++)&#123; dp[i][i] = true; &#125; for(int i=0;i&lt;len-1;i++)&#123; if(s[i]==s[i+1])&#123; dp[i][i+1] = true; maxLen = 2; &#125; &#125; for(int L = 3;L&lt;=len;L++)&#123; for(int i=0;i&lt;len-L+1;i++)&#123; if(dp[i+1][i+L-2]==true&amp;&amp;s[i]==s[i+L-1])&#123; dp[i][i+L-1] = true; maxLen = L; &#125; &#125; &#125; cout &lt;&lt; maxLen; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1039è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1039%2F</url>
    <content type="text"><![CDATA[1039 Course List for Studenté¢˜ç›®1039 Course List for Student ï¼ˆ25 åˆ†ï¼‰Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (â‰¤40,000), the number of students who look for their course lists, and K (â‰¤2,500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students N_iâ€‹â€‹(â‰¤200) are given in a line. Then in the next line, N_â€‹i student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification:For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the studentâ€™s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input:11 54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE11 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB55 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9Sample Output:ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5NON9 0 æ€è·¯å¥½ç®€å•çš„é¢˜ç›®ï¼Œmap&lt;string,vector&lt;int&gt; &gt;å°±å¥½ã€‚å‘çŽ°æœ€åŽä¸€ä¸ªç‚¹è¶…æ—¶äº†æ²¡è¿‡ï¼Œè€ƒè™‘åˆ°æ•°æ®é‡æ¯”è¾ƒå¤§ï¼ŒæŠŠè¾“å…¥è¾“å‡ºä¼˜åŒ–ios::sync_with_stdio(false)åŠ ä¸Šå°±åˆšå¥½è¿‡äº†~çœ‹äº†ä¸€ä¸‹å…¶ä»–äººçš„åšæ³•ï¼Œå› ä¸ºåå­—éƒ½å¾ˆæœ‰è§„å¾‹ï¼Œå¯ä»¥ç›´æŽ¥è½¬æ¢æˆintåž‹å­˜åœ¨æ•°ç»„é‡Œï¼Œæ•ˆçŽ‡è‚¯å®šæ¯”mapè¦é«˜ä¸å°‘ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;map&lt;string,vector&lt;int&gt; &gt; m;int main()&#123; ios::sync_with_stdio(false); int N,K; cin &gt;&gt; N &gt;&gt; K; int index,num; string name; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; index &gt;&gt; num; for(int i=0;i&lt;num;i++)&#123; cin &gt;&gt; name; m[name].push_back(index); &#125; &#125; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; name; sort(m[name].begin(),m[name].end()); cout &lt;&lt; name &lt;&lt; " "; cout &lt;&lt; m[name].size(); for(int j=0;j&lt;m[name].size();j++)&#123; cout &lt;&lt; " " &lt;&lt; m[name][j]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125; ä¸ä½¿ç”¨mapçš„ç‰ˆæœ¬ï¼Œæœ€åŽä¸€ä¸ªcaseçš„ç”¨æ—¶æ¯”ä¸Šé¢çš„ç‰ˆæœ¬é™ä½Žäº†ä¸€åŠï¼Œä½†æ˜¯å…¶ä»–caseçš„ç”¨æ—¶éƒ½å¢žåŠ äº†ä¸€å€å·¦å³å¥½å¥‡æ€ªã€‚æ›´è¯¡å¼‚çš„æ˜¯str2intå‡½æ•°æ”¹ä¸ºå¼•ç”¨ä¼ å‚çš„æ–¹å¼caseçš„ç”¨æ—¶ä¹Ÿä¼šå¢žåŠ â€¦â€¦ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; v[200000];int str2int(string &amp;s)&#123; return (s[0]-'A')*26*26*10+(s[1]-'A')*26*10+(s[2]-'A')*10+s[3]-'0';&#125;int main()&#123; ios::sync_with_stdio(false); int N,K; cin &gt;&gt; N &gt;&gt; K; int index,num; string name; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; index &gt;&gt; num; for(int i=0;i&lt;num;i++)&#123; cin &gt;&gt; name; v[str2int(name)].push_back(index); &#125; &#125; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; name; sort(v[str2int(name)].begin(),v[str2int(name)].end()); cout &lt;&lt; name &lt;&lt; " "; cout &lt;&lt; v[str2int(name)].size(); for(int j=0;j&lt;v[str2int(name)].size();j++)&#123; cout &lt;&lt; " " &lt;&lt; v[str2int(name)][j]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1017è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1017%2F</url>
    <content type="text"><![CDATA[1017 Queueing at Banké¢˜ç›®1017 Queueing at Bank ï¼ˆ25 åˆ†ï¼‰Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour. Now given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (â‰¤10^4) - the total number of customers, and K (â‰¤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time. Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average. Output Specification:For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place. Sample Input:7 307:55:00 1617:00:01 207:59:59 1508:01:00 6008:00:00 3008:00:02 208:03:00 10Sample Output:8.2 æ€è·¯æ€è·¯å‚ç…§é™ˆè¶Šå§¥å§¥çš„ã€Šæ•°æ®ç»“æž„ã€‹8.1é“¶è¡ŒæŽ’é˜Ÿé—®é¢˜ï¼Œç»†èŠ‚æœ‰ç‚¹å¤šï¼Œå¾ˆå®¹æ˜“å†™é”™ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int N,K;int crtTime;int totalTime = 0;int cusNum;struct Customer&#123; int arrive,process; friend bool operator&lt; (Customer c1,Customer c2)&#123; return c1.arrive&gt;c2.arrive; &#125;&#125;;priority_queue&lt;Customer&gt; waitingLine;vector&lt;int&gt; windowsTime;int time(int hh,int mm,int ss)&#123; return hh*3600+mm*60+ss;&#125;int findNextWindows()&#123; int nextWin; int minTime = 999999; for(int i=0;i&lt;K;i++)&#123; if(windowsTime[i]&lt;minTime)&#123; minTime = windowsTime[i]; nextWin = i; &#125; &#125; for(int i=0;i&lt;K;i++) windowsTime[i]-=minTime; crtTime+=minTime; return nextWin;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K; windowsTime.resize(K); fill(windowsTime.begin(),windowsTime.end(),0); int hh,mm,ss,process; char c; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; hh &gt;&gt; c; cin &gt;&gt; mm &gt;&gt; c; cin &gt;&gt; ss &gt;&gt; process; if(time(hh,mm,ss)&lt;=time(17,0,0)) waitingLine.push(Customer&#123;time(hh,mm,ss),process*60&#125;); &#125; cusNum = waitingLine.size(); crtTime = time(8,0,0); while(!waitingLine.empty())&#123; Customer cus = waitingLine.top(); waitingLine.pop(); int nextWin = findNextWindows(); if(cus.arrive&lt;=crtTime)&#123; totalTime+= crtTime-cus.arrive;// cout &lt;&lt; "wait time: " &lt;&lt; crtTime-cus.arrive &lt;&lt; endl; &#125; else&#123; for(int i=0;i&lt;K;i++)&#123; windowsTime[i] = max(windowsTime[i]-(cus.arrive-crtTime),0); &#125; crtTime = cus.arrive; &#125; windowsTime[nextWin] = cus.process; &#125; cout.setf(ios::fixed); cout.precision(1); cout &lt;&lt; double(totalTime)/cusNum/60&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1100,1101,1102,1103è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1100_1101_1102_1103%2F</url>
    <content type="text"><![CDATA[1100 Mars Numbersé¢˜ç›®1100 Mars Numbers ï¼ˆ20 åˆ†ï¼‰People on Mars count their numbers with base 13: Zero on Earth is called â€œtretâ€ on Mars.The numbers 1 to 12 on Earch is called â€œjan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, decâ€ on Mars, respectively.For the next higher digit, Mars people name the 12 numbers as â€œtam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jouâ€, respectively.For examples, the number 29 on Earth is called â€œhel marâ€ on Mars; and â€œelo novâ€ on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars. Output Specification:For each number, print in a line the corresponding number in the other language. Sample Input:4295elo novtamSample Output:hel marmay11513 æ€è·¯é€åˆ†é¢˜ï¼Œæ³¨æ„è¾“å…¥è¾“å‡ºæ ¼å¼ã€‚é™¤éžæ•°å­—æœ¬èº«æ˜¯é›¶ï¼Œå¦åˆ™ä¸è¾“å‡ºæŸä½ä¸Šçš„é›¶ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;map&lt;string,int&gt; str2num = &#123;&#123;"tret",0&#125;,&#123;"jan",1&#125;,&#123;"feb",2&#125;,&#123;"mar",3&#125;,&#123;"apr",4&#125;, &#123;"may",5&#125;,&#123;"jun",6&#125;,&#123;"jly",7&#125;, &#123;"aug",8&#125;,&#123;"sep",9&#125;,&#123;"oct",10&#125;,&#123;"nov",11&#125;,&#123;"dec",12&#125;,&#123;"tam",1*13&#125;,&#123;"hel",2*13&#125;,&#123;"maa",3*13&#125;,&#123;"huh",4*13&#125;, &#123;"tou",5*13&#125;,&#123;"kes",6*13&#125;,&#123;"hei",7*13&#125;, &#123;"elo",8*13&#125;,&#123;"syy",9*13&#125;,&#123;"lok",10*13&#125;,&#123;"mer",11*13&#125;,&#123;"jou",12*13&#125;&#125;;string num2str1[] = &#123;"tret","jan","feb","mar","apr","may","jun","jly","aug","sep","oct","nov","dec"&#125;;string num2str2[] = &#123;"tret","tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mer","jou"&#125;;void ToMars(string s)&#123; int num=0; for(int i=0;i&lt;s.size();i++) num = num*10+ s[i]-'0'; if(num==0)&#123; cout &lt;&lt; num2str1[0] &lt;&lt; "\n"; return; &#125; if(num/13!=0) cout &lt;&lt; num2str2[num/13]; if(num%13!=0)&#123; if(num/13!=0) cout &lt;&lt; " "; cout &lt;&lt; num2str1[num%13]; &#125; cout &lt;&lt; "\n";&#125;void ToEarth(string s1,string s2)&#123; if(s2=="")&#123; cout &lt;&lt; str2num[s1] &lt;&lt; "\n"; &#125; else&#123; cout &lt;&lt; str2num[s2] + str2num[s1] &lt;&lt; "\n"; &#125;&#125;int main()&#123; int N; cin &gt;&gt; N; string s1,s2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; s1; s2 = ""; if(cin.get()!='\n') cin &gt;&gt; s2; if(s2==""&amp;&amp;isdigit(s1[0])) ToMars(s1); else ToEarth(s1,s2); &#125; return 0;&#125; 1101 Quick Sorté¢˜ç›®There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;and for the similar reason, 4 and 5 could also be the pivot.Hence in total there are 3 pivot candidates. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤10â€‹5â€‹â€‹ ). Then the next line contains N distinct positive integers no larger than 10â€‹9â€‹â€‹ . The numbers in a line are separated by spaces. Output Specification:For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:51 3 2 4 5Sample Output:31 4 5 æ€è·¯æ²¡ä»€ä¹ˆæ€è·¯ï¼Œå…ˆæƒ³ç€æžšä¸¾æ³•è¯•ä¸€ä¸‹ï¼Œæžœç„¶å¥½å‡ ä¸ªç‚¹è¿‡ä¸äº†ã€‚ç„¶åŽçœ‹äº†ä¸€ä¸‹ç½‘ä¸Šçš„åšæ³•ï¼ŒåŽŸæ¥è¿™ä¹ˆç®€å•â€¦â€¦æ€æƒ³å°±æ˜¯å¦‚æžœæŸä¸ªä½ç½®çš„æ•°å­—æ¯”å·¦è¾¹çš„æœ€å¤§å€¼è¿˜è¦å¤§ï¼Œå¹¶ä¸”æ¯”å³è¾¹çš„æœ€å°å€¼è¿˜è¦å°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯pivotã€‚é‚£å°±å…ˆä»Žå·¦å‘å³æ‰«æä¸€æ¬¡ï¼Œæ±‚å‡ºmaxL[i]ï¼Œå³ä¸‹æ ‡ä»Ž0åˆ°iä½ç½®ä¸Šæœ€å¤§çš„æ•°ï¼›åŒç†ä»Žå³å‘å·¦æ‰«æä¸€æ¬¡ï¼Œæ±‚å‡ºminR[i]ã€‚å¦‚æžœmaxL[i]==minR[i]çš„è¯é‚£è¿™ä¸ªæ•°å°±å¯ä»¥ä½œä¸ºpivotã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int num[100010];int maxL[100010];int minR[100010];vector&lt;int&gt; v;int main()&#123; ios::sync_with_stdio(false); int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; num[i]; int max = num[0]; for(int i=0;i&lt;N;i++)&#123; if(num[i]&gt;max) max = num[i]; maxL[i] = max; &#125; int min = num[N-1]; for(int i=N-1;i&gt;=0;i--)&#123; if(num[i]&lt;min) min = num[i]; minR[i] = min; &#125; for(int i=0;i&lt;N;i++)&#123; if(num[i]==maxL[i] &amp;&amp; num[i] == minR[i]) v.push_back(num[i]); &#125; sort(v.begin(),v.end()); int len = v.size(); cout &lt;&lt; len &lt;&lt; "\n"; for(int i=0;i&lt;len;i++)&#123; if(i!=0) cout &lt;&lt; " "; cout &lt;&lt; v[i]; &#125; cout &lt;&lt; "\n"; return 0;&#125; 1102 Invert a Binary Treeé¢˜ç›®1102 Invert a Binary Tree ï¼ˆ25 åˆ†ï¼‰The following is from Max Howell @twitter: Google: 90% of our engineers use the software you wrote (Homebrew), but you canâ€™t invert a binary tree on a whiteboard so fuck off.Now itâ€™s your turn to prove that YOU CAN invert a binary tree! Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤10) which is the total number of nodes in the tree â€“ and hence the nodes are numbered from 0 to Nâˆ’1. Then N lines follow, each corresponds to a node from 0 to Nâˆ’1, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification:For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:81 -- -0 -2 7- -- -5 -4 6Sample Output:3 7 2 6 4 0 5 16 5 7 4 3 2 0 1 æ€è·¯å¬è¿‡è¿™ä¸ªæ•…äº‹çš„ï¼Œåè½¬äºŒå‰æ ‘æ„Ÿè§‰çœŸçš„ä¸éš¾å‘€- -ä¸è¿‡å…¶å®žè¿™é“é¢˜ç›®å¹¶ä¸ç”¨åè½¬ï¼Œåªè¦éåŽ†çš„æ—¶å€™ï¼ŒæŠŠæ­£å¸¸çš„å…ˆå·¦èŠ‚ç‚¹åŽå³èŠ‚ç‚¹çš„é¡ºåºåè¿‡æ¥å°±å¥½ã€‚è¿˜æœ‰éœ€è¦æ³¨æ„çš„å°±æ˜¯æ ‘çš„æ ¹èŠ‚ç‚¹å¹¶ä¸æ˜¯ä»Ž0å¼€å§‹ï¼Œæ‰€ä»¥è¦å…ˆæ‰¾ä¸€ä¸‹æ ¹èŠ‚ç‚¹ã€‚æ°´é¢˜ä¸€é“ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int nLeft[10];int nRight[10];bool isChild[10];queue&lt;int&gt; Q;int root;bool first=true;void inOrder(int n)&#123; if(nRight[n]!=-1) inOrder(nRight[n]); if(first) first = false; else cout &lt;&lt; " "; cout &lt;&lt; n; if(nLeft[n]!=-1) inOrder(nLeft[n]);&#125;int main()&#123; int N; cin &gt;&gt; N; char c1,c2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; c1 &gt;&gt; c2; nLeft[i] = c1=='-'?-1:(c1-'0'); nRight[i] = c2=='-'?-1:(c2-'0'); &#125; //find root for(int i=0;i&lt;N;i++)&#123; if(nLeft[i]!=-1) isChild[nLeft[i]] = true; if(nRight[i]!=-1) isChild[nRight[i]] = true; &#125; for(int i=0;i&lt;N;i++) &#123; if(!isChild[i]) root = i; &#125; //level order Q.push(root); while(!Q.empty())&#123; int tmp = Q.front(); if(tmp!=root) cout &lt;&lt; " "; cout &lt;&lt; tmp; Q.pop(); if(nRight[tmp]!=-1) Q.push(nRight[tmp]); if(nLeft[tmp]!=-1) Q.push(nLeft[tmp]); &#125; cout &lt;&lt; "\n"; //in-order travelsal inOrder(root); return 0;&#125; 1103 Integer Factorizationé¢˜ç›® æ€è·¯æƒ³äº†åŠå¤©ï¼Œæ„Ÿè§‰æ˜¯DFSï¼Œä½†æ˜¯è¿˜æ˜¯æ— ä»Žä¸‹æ‰‹â€¦â€¦å‚è€ƒäº†æŸ³ç¥žçš„ä»£ç ï¼Œä½†æ˜¯è¯¥ä»£ç åœ¨æˆ‘ç”µè„‘ä¸Šè¿è¡Œæœ‰é—®é¢˜ï¼Œdoubleçš„powå¼ºåˆ¶ç±»åž‹è½¬æ¢æˆintä¹‹åŽä¼šäº§ç”Ÿè¯¯å·®ã€‚å¥½äº†è¯´ä¸€ä¸‹æ€è·¯ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªDFS+å‰ªæžçš„é—®é¢˜ï¼Œé¦–å…ˆåˆå§‹åŒ–ä¸€ä¸ªpowPæ•°ç»„ä»¥é¿å…é‡å¤è¿›è¡Œæ¬¡æ–¹è¿ç®—ã€‚ç„¶åŽç”¨tmpSeqæ¥ä¸´æ—¶è®°å½•å½“å‰çš„â€œè·¯å¾„â€ã€‚ç„¶åŽå¼€å§‹dfsï¼šé€’å½’ç»ˆæ­¢çš„æ¡ä»¶æ˜¯å› æ•°çš„æ•°é‡è¾¾åˆ°äº†Kï¼Œç„¶åŽåˆ¤æ–­ä¸€ä¸‹å½“å‰çš„kä¸ªæ•°æ˜¯å¦æ»¡è¶³é¢˜ç›®çš„æ¡ä»¶ï¼Œå¦‚æžœæ»¡è¶³å¹¶ä¸”facSumæ›´å¤§ï¼Œå°±è®°å½•ä¸‹æ¥ã€‚å¦‚æžœæ²¡æœ‰è¾¾åˆ°kä¸ªæ•°ï¼Œå°±ç»§ç»­å¾€ä¸‹é€’å½’ã€‚å¾€ä¸‹é€’å½’éœ€è¦æ³¨æ„ï¼š1.ä¸‹ä¸€ä¸ªæ•°çš„ä¸Šç•Œçš„é€‰å–ï¼Œç¬¬ä¸€ä¸ªæ•°å°±å–sqrt(N)ï¼ŒåŽé¢çš„æ•°çš„ä¸Šç•Œæ˜¯å‰ä¸€ä¸ªæ•°ï¼ˆç”±äºŽå¯¹ç§°æ€§ï¼Œåªéœ€è¦è€ƒè™‘é™åºæŽ’åˆ—çš„æƒ…å†µï¼Œå¦åˆ™è®¡ç®—é‡å°†æ€¥å‰§å¢žåŠ ï¼‰ã€‚2.å½“sum+powP[i]&lt;=Næ—¶æ‰å‘ä¸‹é€’å½’ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int N,K,P;int powP[30];vector&lt;int&gt; bestSqe;vector&lt;int&gt; tmpSqe;int maxFacSum =-1;int bound;void powInit()&#123; powP[0] = 0;powP[1] = 1; int sum=1,i=2,p; while(sum&lt;=N) &#123; sum = 1; p = P; while(p--) sum*=i; powP[i] = sum; i++; &#125; bound = i-1;&#125;//kï¼šç¬¬kä¸ªæ•°//sumï¼šå‰kä¸ªå› æ•°çš„Pæ¬¡æ–¹çš„å’Œ//facSumï¼šå‰kä¸ªå› æ•°çš„å’Œvoid dfs(int k,int sum,int facSum)&#123;// cout &lt;&lt; k &lt;&lt;" " &lt;&lt;sum &lt;&lt; " " &lt;&lt; facSum &lt;&lt; endl; if(k==K)&#123; if(sum == N&amp;&amp;facSum&gt;maxFacSum)&#123; bestSqe = tmpSqe; maxFacSum = facSum; &#125; return; &#125; //ç¡®ä¿åºåˆ—æ˜¯é€’å‡çš„ int upBound = k==0?bound:tmpSqe[k-1]; for(int i = upBound;i&gt;=1;i--)&#123; if(sum+powP[i]&lt;=N)&#123; tmpSqe[k] = i; dfs(k+1,sum+powP[i],facSum+i); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; P; powInit(); tmpSqe.resize(K); dfs(0,0,0); if(maxFacSum==-1)&#123; cout &lt;&lt; "Impossible\n"; return 0; &#125; cout &lt;&lt; N &lt;&lt; " = "; for(int i=0;i&lt;bestSqe.size();i++)&#123; if(i!=0) cout &lt;&lt; " + "; cout &lt;&lt; bestSqe[i]&lt;&lt; "^" &lt;&lt; P; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1096,1097,1098,1099è§£é¢˜æŠ¥å‘Š]]></title>
    <url>%2Fpost%2FPAT_1096_1097_1098_1099%2F</url>
    <content type="text"><![CDATA[1096 Consecutive Factorsé¢˜ç›®1096 Consecutive Factors ï¼ˆ20 åˆ†ï¼‰ Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3Ã—5Ã—6Ã—7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification:Each input file contains one test case, which gives the integer N (1&lt;N&lt;2^â€‹31â€‹). Output Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]factor[2]â€¦*factor[k], where the factors are listed in increasing order, and 1 is NOT included. Sample Input:630Sample Output:3567 æ€è·¯é¢˜ç›®çš„æ„æ€æ˜¯è®©æ‰¾åˆ°ä¸€ä¸ªæ•´æ•°æœ€é•¿çš„è¿žç»­çš„å› æ•°ï¼ˆä¸æ˜¯è´¨å› æ•°ï¼‰ã€‚ä¸€å¼€å§‹å®Œå…¨æ²¡å¤´ç»ªçš„é¢˜ç›®ï¼Œä¸€å¼€å§‹æƒ³å…ˆåˆ†è§£æˆè´¨å› æ•°ï¼Œä½†æ˜¯å› æ•°çš„ç»„åˆä¹Ÿå¾ˆéº»çƒ¦â€¦â€¦é‚£å°±ä¸å¦¨æš´åŠ›æ±‚è§£ä¸€ä¸‹~è™½ç„¶çŸ¥é“å› å­çš„ä¸Šç•Œæ˜¯sqrt(N),ä½†ä¸€å¼€å§‹å·æ‡’å…ˆå†™çš„æ˜¯N/2ï¼Œæžœç„¶æœ‰ä¸€ä¸ªæµ‹è¯•ç‚¹è¿‡ä¸äº†ã€‚ç„¶åŽæƒ³æƒ³ï¼Œ2^31æ•°é‡çº§çš„æƒ…å†µä¸‹ï¼Œsqrt(N)å’ŒN/2å·®äº†å¥½å¤šå¥½å¤šã€‚æ”¹æˆsqrt(N)å°±æžœæ–­è¿‡äº†ã€‚æ³¨æ„è¦ç”¨&lt;=,å¦åˆ™N=4çš„æ—¶å€™ä¼šå‡ºé”™ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt; factors;int main()&#123; int N; cin &gt;&gt; N; int maxNum = 1; factors.push_back(N); int sq = sqrt(N); //numä¸ªè¿žç»­å› å­ for(int num = 1;num&lt;13;num++)&#123; //è¿žç»­å› å­ä»Žstartå¼€å§‹ bool end = false; for(int start = 2;start&lt;=sq;start++)&#123; //è®¡ç®—æ˜¯å¦å­˜åœ¨åˆé€‚çš„è¿žç»­å› å­ int product = 1; for(int i=start;i&lt;start+num;i++) product*=i; if(product&gt;N)&#123; end = true; break; &#125;else if(N%product==0)&#123; factors.clear(); for(int i = start;i&lt;start+num;i++) &#123; factors.push_back(i); &#125; maxNum = num; break; &#125; &#125; if(end) break; &#125; cout &lt;&lt; maxNum &lt;&lt; "\n"; for(int i=0;i&lt;factors.size();i++)&#123; if(i!=0) cout &lt;&lt;"*"; cout &lt;&lt; factors[i]; &#125; return 0;&#125; 1097 Deduplication on a Linked Listé¢˜ç›®1097 Deduplication on a Linked List ï¼ˆ25 åˆ†ï¼‰Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21â†’-15â†’-15â†’-7â†’15, you must output 21â†’-15â†’-7, and the removed list -15â†’15. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (â‰¤10^5â€‹â€‹ ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by âˆ’1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the position of the node, Key is an integer of which absolute value is no more than 10^4â€‹, and Next is the position of the next node. Output Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:00100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854Sample Output:00100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 æ€è·¯åˆ é™¤ä¸€ä¸ªé“¾è¡¨ä¸­ç»å¯¹å€¼ç›¸åŒçš„èŠ‚ç‚¹ï¼Œåªä¿ç•™ç¬¬ä¸€ä¸ªã€‚ç®€å•çš„é“¾è¡¨åˆ é™¤ï¼Œåˆ é™¤ä¹‹åŽæŠŠåˆ æŽ‰çš„èŠ‚ç‚¹è®°å½•åœ¨lastDeleteä¸­ï¼Œç„¶åŽåˆ é™¤ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼ŒæŠŠlastdeleteæŒ‡å‘è¿™ä¸ªè¢«åˆ é™¤çš„èŠ‚ç‚¹ã€‚æœ€åŽæŠŠlastDeleteæŒ‡å‘-1ã€‚ä¸€å¼€å§‹è¾“å‡ºçš„æ—¶å€™å¿˜äº†æŠŠnextä¹Ÿè¦å¡«å……åˆ°5ä½ï¼Œè€Œç¤ºä¾‹çš„è¾“å…¥è¾“å‡ºåˆåˆšå¥½nextéƒ½æ˜¯äº”ä½çš„â€¦â€¦åœ¨è¿™ä¸ªå‘çˆ¹çš„é—®é¢˜ä¸Šå¡äº†å¥½ä¹…ã€‚ä¸ºä»€ä¹ˆPATçš„è¾“å…¥è¾“å‡ºæ€»æ˜¯è¿™ä¹ˆçš„è®©æˆ‘å´©æºƒã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Node&#123; int value; int next;&#125;;Node List[100010];set&lt;int&gt; s;int lastDelete = -1;int firstDelete = -1;void output(int root)&#123; int temp = root; while(temp!=-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; temp &lt;&lt; " " &lt;&lt; List[temp].value &lt;&lt; " " ; if(List[temp].next!=-1)&#123; cout.width(5); cout.fill('0'); &#125; cout &lt;&lt; List[temp].next &lt;&lt; "\n"; temp = List[temp].next; &#125;&#125;int main()&#123; int N,start; cin &gt;&gt; start &gt;&gt; N; int pos; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; pos; cin &gt;&gt; List[pos].value; cin &gt;&gt; List[pos].next; &#125; int pre = start; s.insert(abs(List[start].value)); while(List[pre].next!=-1)&#123; int now = List[pre].next; //æ— éœ€åˆ é™¤ï¼Œç»§ç»­æŸ¥æ‰¾ if(s.count(abs(List[now].value))==0) &#123; s.insert(abs(List[now].value)); pre = now; &#125;else&#123;//åˆ é™¤èŠ‚ç‚¹// cout &lt;&lt; "delete: " &lt;&lt;now &lt;&lt; endl; List[pre].next = List[now].next; if(lastDelete==-1) &#123; firstDelete = now; &#125; else&#123; List[lastDelete].next = now; &#125; lastDelete = now; &#125; &#125; List[lastDelete].next = -1; output(start); output(firstDelete); return 0;&#125; 1098 Insertion or Heap Sorté¢˜ç›®1098 Insertion or Heap Sort ï¼ˆ25 åˆ†ï¼‰According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification:For each test case, print in the first line either â€œInsertion Sortâ€ or â€œHeap Sortâ€ to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0Sample Output 1:Insertion Sort1 2 3 5 7 8 9 4 6 0Sample Input 2:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9Sample Output 2:Heap Sort5 4 3 1 0 2 6 7 8 9 æ€è·¯ç»™å‡ºä¸€ä¸ªåºåˆ—ï¼ŒåŠæŽ’åºåˆ°ä¸€åŠçš„åºåˆ—ï¼Œåˆ¤æ–­åˆ°åº•æ˜¯æ’å…¥æŽ’åºè¿˜æ˜¯å †æŽ’åºï¼Œç„¶åŽå†è¿›è¡Œä¸‹ä¸€æ­¥ã€‚ä¸»è¦è€ƒå¯Ÿå¯¹æ’å…¥æŽ’åºåŠå †æŽ’åºçš„ç†Ÿæ‚‰ç¨‹åº¦ã€‚å› ä¸ºæ’å…¥æŽ’åºæ¯”è¾ƒå¥½å†™ï¼Œæ‰€ä»¥å°±å…ˆä¸€æ­¥ä¸€æ­¥çš„æ‰§è¡Œæ’å…¥æŽ’åºï¼Œå’Œç»™å®šçš„åºåˆ—è¿›è¡Œæ¯”è¾ƒï¼Œç›¸åŒè¯´æ˜Žæ˜¯æ’å…¥æŽ’åºï¼Œå¦‚æžœæŽ’åºå®Œæˆè¿˜ä¸åŒè¯´æ˜Žæ˜¯å †æŽ’åºã€‚åˆ¤æ–­å‡ºå †æŽ’åºåŽï¼Œå› ä¸ºå †æŽ’åºpopçš„æ¯ä¸€ä¸ªæ•°éƒ½æ˜¯å †ä¸­çš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥å †æŽ’åºåºåˆ—åŽé¢çš„éƒ½æ˜¯æœ€å¤§å€¼ï¼Œå’Œä¹‹å‰æ’å…¥æŽ’åºå·²ç»æŽ’å¥½çš„é˜Ÿåˆ—è¿›è¡Œæ¯”è¾ƒï¼Œå°±èƒ½æ‰¾åˆ°æŽ’åºè¿›è¡Œåˆ°å“ªä¸€æ­¥äº†ï¼Œå†è¿›è¡Œä¸€æ­¥æŽ’åºå°±å¥½ã€‚ä¸ºäº†æ–¹ä¾¿æ’å…¥æŽ’åºçš„æ¯”è¾ƒå’Œå †æŽ’åºçš„ä¸‹æ ‡è¿ç®—ï¼Œæ•°ç»„å­˜æ”¾ä»Ž1å¼€å§‹ï¼Œ0çš„å€¼è®¾ä¸º-1åæ ‡æ ‡å…µã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;int ori[110] = &#123;-1&#125;;int ins[110] = &#123;-1&#125;;int sorted[110] = &#123;-1&#125;;int N;//å°†ç¬¬nä¸ªå…ƒç´ æ’å…¥åˆ°å‰n-1ä¸ªå…ƒç´ ä¸­åˆé€‚çš„ä½ç½®void Insertion(int arr[],int n)&#123; for(int i = n-1;i&gt;=0;i--)&#123; if(arr[n]&gt;arr[i])&#123; int temp = arr[n]; for(int j=n;j&gt;i+1;j--)&#123; arr[j] = arr[j-1]; &#125; arr[i+1] = temp; break; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N; for(int i=1;i&lt;=N;i++) &#123;cin &gt;&gt;ori[i];ins[i] = ori[i];&#125; for(int i=1;i&lt;=N;i++) cin &gt;&gt; sorted[i]; bool same; for(int j=2;j&lt;=N;j++)&#123; same = true; Insertion(ins,j);// for(int i=1;i&lt;=N;i++) cout &lt;&lt; ins[i] &lt;&lt; " ";// cout &lt;&lt; endl; for(int i=1;i&lt;=N;i++)&#123; if(ins[i]!=sorted[i])&#123; same = false; break; &#125; &#125; if(same)&#123; cout &lt;&lt; "Insertion Sort\n"; Insertion(ins,j+1); for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; ins[i]; &#125; return 0; &#125; &#125; int flag = N; for(;flag&gt;=1;flag--)&#123; if(sorted[flag]!=ins[flag]) break; &#125; int tem = sorted[flag]; sorted[flag] = sorted[1]; int prt = 1; while(prt*2&lt;flag)&#123; int chd = (prt*2+1==flag||sorted[prt*2]&gt;sorted[prt*2+1])?prt*2:prt*2+1; if(tem&gt;=sorted[chd]) break; sorted[prt] = sorted[chd];// cout &lt;&lt; prt &lt;&lt; " " &lt;&lt; chd &lt;&lt; endl; prt = chd; &#125; sorted[prt] = tem; cout &lt;&lt; "Heap Sort\n"; for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; sorted[i]; &#125; return 0;&#125; 1099 Build A Binary Search Treeé¢˜ç›®1099 Build A Binary Search Tree ï¼ˆ30 åˆ†ï¼‰A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key.The right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.Both the left and right subtrees must also be binary search trees.Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to Nâˆ’1, and 0 is always the root. If one child is missing, then âˆ’1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input:91 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42Sample Output:58 25 82 11 38 67 45 73 42 æ€è·¯è€ƒå¯ŸäºŒå‰æ ‘çš„æ“ä½œã€‚å…ˆç”¨é€’å½’æŠŠå„ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æ•°é‡ç®—å‡ºæ¥ï¼Œå†ç”¨é€’å½’æŠŠæŽ’åºåŽçš„æ•°å­—å¡«å…¥èŠ‚ç‚¹ä¸­ã€‚å†ç”¨ä¸ªé˜Ÿåˆ—å±‚åºéåŽ†æ•´æ£µæ ‘å¹¶è¾“å‡ºã€‚çœ‹äº†ä¸€ä¸‹åˆ«äººçš„ç­”æ¡ˆå‘çŽ°ï¼ŒäºŒå‰æœç´¢æ ‘çš„ä¸­åºéåŽ†åŽŸæ¥å°±æ˜¯æŒ‰æ•°å€¼ä»Žå°åˆ°å¤§éåŽ†ä¸€éï¼Œé‚£ç›´æŽ¥ä¸­åºéåŽ†å¡«æ•°å€¼ï¼Œå±‚åºéåŽ†è¾“å‡ºå°±å¥½ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;struct Node&#123; int value; int left,right; int leftNum,rightNum;&#125;;Node Tree[110];int N;vector&lt;int&gt; v;int CalChildrenNum(int root)&#123; Tree[root].leftNum = Tree[root].left==-1?0:(CalChildrenNum(Tree[root].left)+1); Tree[root].rightNum = Tree[root].right==-1?0:(CalChildrenNum(Tree[root].right)+1);// cout &lt;&lt; "Children Number of " &lt;&lt; root &lt;&lt; " is" &lt;&lt; Tree[root].leftNum+Tree[root].rightNum &lt;&lt; endl; return Tree[root].leftNum+Tree[root].rightNum;&#125;void build(int root,int from)&#123; Tree[root].value = v[from + Tree[root].leftNum];// cout &lt;&lt; "root: " &lt;&lt; root &lt;&lt; " value:" &lt;&lt; Tree[root].value &lt;&lt; endl; if(Tree[root].left!=-1) build(Tree[root].left,from); if(Tree[root].right!=-1) build(Tree[root].right,from + Tree[root].leftNum+1);&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; Tree[i].left &gt;&gt; Tree[i].right; &#125; int tem; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; tem; v.push_back(tem); &#125; sort(v.begin(),v.end()); CalChildrenNum(0); build(0,0); queue&lt;int&gt; q; q.push(0); while(!q.empty())&#123; int p = q.front(); q.pop(); if(p!=0) cout &lt;&lt; " "; cout &lt;&lt; Tree[p].value; if(Tree[p].left!=-1) q.push(Tree[p].left); if(Tree[p].right!=-1) q.push(Tree[p].right); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç¬¬ä¸€ç¯‡æ–‡ç« ]]></title>
    <url>%2Fpost%2Ffirst_article%2F</url>
    <content type="text"><![CDATA[åšå®¢ç»ˆäºŽæ­å»ºå®Œæˆäº†ï¼ç»è¿‡åƒè¾›ä¸‡è‹¦ï¼ˆé•¿è¾¾ä¸¤å¤©çš„åŠªåŠ›ï¼‰ï¼Œæˆ‘çš„åšå®¢ç»ˆäºŽä¸Šçº¿äº†ï¼ä»¥åŽä¼šåœ¨è¿™é‡Œè®°å½•ä¸€äº›ç§‘ç ”ä»¥åŠå­¦ä¹ çš„å¿ƒå¾—ã€‚ è®©æˆ‘å…ˆè¯•ç€æ”¾å¼ å›¾ç‰‡ï¼š ä¸‹é¢æ”¾ä¸€æ®µä»£ç 12str = "Hello world!"print(str) ä¸‹é¢æ˜¯ä¸€ä¸ªè¡¨æ ¼ AND true false true true false false false false 1.hexoä»Žé›¶å¼€å§‹åˆ°æ­å»ºå®Œæ•´2.Hexoä¸‹çš„Markdownè¯­æ³•(GFM)å†™åšå®¢3.Hexoæ­å»ºçš„GitHubåšå®¢ä¹‹ä¼˜åŒ–å¤§å…¨4.Hexo å®˜ç½‘5.Next ä½¿ç”¨æ–‡æ¡£]]></content>
      <categories>
        <category>å…¶ä»–</category>
      </categories>
  </entry>
</search>
