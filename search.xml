<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT-1039解题报告]]></title>
    <url>%2Fpost%2FPAT_1039%2F</url>
    <content type="text"><![CDATA[1039 Course List for Student题目1039 Course List for Student （25 分）Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤40,000), the number of students who look for their course lists, and K (≤2,500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students N​i​​ (≤200) are given in a line. Then in the next line, N​i​​ student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification:For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student’s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input:11 54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE11 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB55 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9Sample Output:ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5NON9 0 思路好简单的题目，map&lt;string,vector&lt;int&gt; &gt;就好。发现最后一个点超时了没过，考虑到数据量比较大，把输入输出优化ios::sync_with_stdio(false)加上就刚好过了~看了一下其他人的做法，因为名字都很有规律，可以直接转换成int型存在数组里，效率肯定比map要高不少。 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;map&lt;string,vector&lt;int&gt; &gt; m;int main()&#123; ios::sync_with_stdio(false); int N,K; cin &gt;&gt; N &gt;&gt; K; int index,num; string name; for(int i=0;i&lt;K;i++)&#123; cin &gt;&gt; index &gt;&gt; num; for(int i=0;i&lt;num;i++)&#123; cin &gt;&gt; name; m[name].push_back(index); &#125; &#125; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; name; sort(m[name].begin(),m[name].end()); cout &lt;&lt; name &lt;&lt; " "; cout &lt;&lt; m[name].size(); for(int j=0;j&lt;m[name].size();j++)&#123; cout &lt;&lt; " " &lt;&lt; m[name][j]; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-1017解题报告]]></title>
    <url>%2Fpost%2FPAT_1017%2F</url>
    <content type="text"><![CDATA[1017 Queueing at Bank题目1017 Queueing at Bank （25 分）Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour. Now given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤10^4) - the total number of customers, and K (≤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time. Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average. Output Specification:For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place. Sample Input:7 307:55:00 1617:00:01 207:59:59 1508:01:00 6008:00:00 3008:00:02 208:03:00 10Sample Output:8.2 思路思路参照陈越姥姥的《数据结构》8.1银行排队问题，细节有点多，很容易写错。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int N,K;int crtTime;int totalTime = 0;int cusNum;struct Customer&#123; int arrive,process; friend bool operator&lt; (Customer c1,Customer c2)&#123; return c1.arrive&gt;c2.arrive; &#125;&#125;;priority_queue&lt;Customer&gt; waitingLine;vector&lt;int&gt; windowsTime;int time(int hh,int mm,int ss)&#123; return hh*3600+mm*60+ss;&#125;int findNextWindows()&#123; int nextWin; int minTime = 999999; for(int i=0;i&lt;K;i++)&#123; if(windowsTime[i]&lt;minTime)&#123; minTime = windowsTime[i]; nextWin = i; &#125; &#125; for(int i=0;i&lt;K;i++) windowsTime[i]-=minTime; crtTime+=minTime; return nextWin;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K; windowsTime.resize(K); fill(windowsTime.begin(),windowsTime.end(),0); int hh,mm,ss,process; char c; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; hh &gt;&gt; c; cin &gt;&gt; mm &gt;&gt; c; cin &gt;&gt; ss &gt;&gt; process; if(time(hh,mm,ss)&lt;=time(17,0,0)) waitingLine.push(Customer&#123;time(hh,mm,ss),process*60&#125;); &#125; cusNum = waitingLine.size(); crtTime = time(8,0,0); while(!waitingLine.empty())&#123; Customer cus = waitingLine.top(); waitingLine.pop(); int nextWin = findNextWindows(); if(cus.arrive&lt;=crtTime)&#123; totalTime+= crtTime-cus.arrive;// cout &lt;&lt; "wait time: " &lt;&lt; crtTime-cus.arrive &lt;&lt; endl; &#125; else&#123; for(int i=0;i&lt;K;i++)&#123; windowsTime[i] = max(windowsTime[i]-(cus.arrive-crtTime),0); &#125; crtTime = cus.arrive; &#125; windowsTime[nextWin] = cus.process; &#125; cout.setf(ios::fixed); cout.precision(1); cout &lt;&lt; double(totalTime)/cusNum/60&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1100,1101,1102,1103解题报告]]></title>
    <url>%2Fpost%2FPAT_1100_1101_1102_1103%2F</url>
    <content type="text"><![CDATA[1100 Mars Numbers题目1100 Mars Numbers （20 分）People on Mars count their numbers with base 13: Zero on Earth is called “tret” on Mars.The numbers 1 to 12 on Earch is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.For the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.For examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars. Output Specification:For each number, print in a line the corresponding number in the other language. Sample Input:4295elo novtamSample Output:hel marmay11513 思路送分题，注意输入输出格式。除非数字本身是零，否则不输出某位上的零。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;map&lt;string,int&gt; str2num = &#123;&#123;"tret",0&#125;,&#123;"jan",1&#125;,&#123;"feb",2&#125;,&#123;"mar",3&#125;,&#123;"apr",4&#125;, &#123;"may",5&#125;,&#123;"jun",6&#125;,&#123;"jly",7&#125;, &#123;"aug",8&#125;,&#123;"sep",9&#125;,&#123;"oct",10&#125;,&#123;"nov",11&#125;,&#123;"dec",12&#125;,&#123;"tam",1*13&#125;,&#123;"hel",2*13&#125;,&#123;"maa",3*13&#125;,&#123;"huh",4*13&#125;, &#123;"tou",5*13&#125;,&#123;"kes",6*13&#125;,&#123;"hei",7*13&#125;, &#123;"elo",8*13&#125;,&#123;"syy",9*13&#125;,&#123;"lok",10*13&#125;,&#123;"mer",11*13&#125;,&#123;"jou",12*13&#125;&#125;;string num2str1[] = &#123;"tret","jan","feb","mar","apr","may","jun","jly","aug","sep","oct","nov","dec"&#125;;string num2str2[] = &#123;"tret","tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mer","jou"&#125;;void ToMars(string s)&#123; int num=0; for(int i=0;i&lt;s.size();i++) num = num*10+ s[i]-'0'; if(num==0)&#123; cout &lt;&lt; num2str1[0] &lt;&lt; "\n"; return; &#125; if(num/13!=0) cout &lt;&lt; num2str2[num/13]; if(num%13!=0)&#123; if(num/13!=0) cout &lt;&lt; " "; cout &lt;&lt; num2str1[num%13]; &#125; cout &lt;&lt; "\n";&#125;void ToEarth(string s1,string s2)&#123; if(s2=="")&#123; cout &lt;&lt; str2num[s1] &lt;&lt; "\n"; &#125; else&#123; cout &lt;&lt; str2num[s2] + str2num[s1] &lt;&lt; "\n"; &#125;&#125;int main()&#123; int N; cin &gt;&gt; N; string s1,s2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; s1; s2 = ""; if(cin.get()!='\n') cin &gt;&gt; s2; if(s2==""&amp;&amp;isdigit(s1[0])) ToMars(s1); else ToEarth(s1,s2); &#125; return 0;&#125; 1101 Quick Sort题目There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;and for the similar reason, 4 and 5 could also be the pivot.Hence in total there are 3 pivot candidates. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10​5​​ ). Then the next line contains N distinct positive integers no larger than 10​9​​ . The numbers in a line are separated by spaces. Output Specification:For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:51 3 2 4 5Sample Output:31 4 5 思路没什么思路，先想着枚举法试一下，果然好几个点过不了。然后看了一下网上的做法，原来这么简单……思想就是如果某个位置的数字比左边的最大值还要大，并且比右边的最小值还要小，那么这个数就是pivot。那就先从左向右扫描一次，求出maxL[i]，即下标从0到i位置上最大的数；同理从右向左扫描一次，求出minR[i]。如果maxL[i]==minR[i]的话那这个数就可以作为pivot。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int num[100010];int maxL[100010];int minR[100010];vector&lt;int&gt; v;int main()&#123; ios::sync_with_stdio(false); int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++) cin &gt;&gt; num[i]; int max = num[0]; for(int i=0;i&lt;N;i++)&#123; if(num[i]&gt;max) max = num[i]; maxL[i] = max; &#125; int min = num[N-1]; for(int i=N-1;i&gt;=0;i--)&#123; if(num[i]&lt;min) min = num[i]; minR[i] = min; &#125; for(int i=0;i&lt;N;i++)&#123; if(num[i]==maxL[i] &amp;&amp; num[i] == minR[i]) v.push_back(num[i]); &#125; sort(v.begin(),v.end()); int len = v.size(); cout &lt;&lt; len &lt;&lt; "\n"; for(int i=0;i&lt;len;i++)&#123; if(i!=0) cout &lt;&lt; " "; cout &lt;&lt; v[i]; &#125; cout &lt;&lt; "\n"; return 0;&#125; 1102 Invert a Binary Tree题目1102 Invert a Binary Tree （25 分）The following is from Max Howell @twitter: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.Now it’s your turn to prove that YOU CAN invert a binary tree! Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node from 0 to N−1, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification:For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:81 -- -0 -2 7- -- -5 -4 6Sample Output:3 7 2 6 4 0 5 16 5 7 4 3 2 0 1 思路听过这个故事的，反转二叉树感觉真的不难呀- -不过其实这道题目并不用反转，只要遍历的时候，把正常的先左节点后右节点的顺序反过来就好。还有需要注意的就是树的根节点并不是从0开始，所以要先找一下根节点。水题一道。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int nLeft[10];int nRight[10];bool isChild[10];queue&lt;int&gt; Q;int root;bool first=true;void inOrder(int n)&#123; if(nRight[n]!=-1) inOrder(nRight[n]); if(first) first = false; else cout &lt;&lt; " "; cout &lt;&lt; n; if(nLeft[n]!=-1) inOrder(nLeft[n]);&#125;int main()&#123; int N; cin &gt;&gt; N; char c1,c2; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; c1 &gt;&gt; c2; nLeft[i] = c1=='-'?-1:(c1-'0'); nRight[i] = c2=='-'?-1:(c2-'0'); &#125; //find root for(int i=0;i&lt;N;i++)&#123; if(nLeft[i]!=-1) isChild[nLeft[i]] = true; if(nRight[i]!=-1) isChild[nRight[i]] = true; &#125; for(int i=0;i&lt;N;i++) &#123; if(!isChild[i]) root = i; &#125; //level order Q.push(root); while(!Q.empty())&#123; int tmp = Q.front(); if(tmp!=root) cout &lt;&lt; " "; cout &lt;&lt; tmp; Q.pop(); if(nRight[tmp]!=-1) Q.push(nRight[tmp]); if(nLeft[tmp]!=-1) Q.push(nLeft[tmp]); &#125; cout &lt;&lt; "\n"; //in-order travelsal inOrder(root); return 0;&#125; 1103 Integer Factorization题目 思路想了半天，感觉是DFS，但是还是无从下手……参考了柳神的代码，但是该代码在我电脑上运行有问题，double的pow强制类型转换成int之后会产生误差。好了说一下思路，这就是一个DFS+剪枝的问题，首先初始化一个powP数组以避免重复进行次方运算。然后用tmpSeq来临时记录当前的“路径”。然后开始dfs：递归终止的条件是因数的数量达到了K，然后判断一下当前的k个数是否满足题目的条件，如果满足并且facSum更大，就记录下来。如果没有达到k个数，就继续往下递归。往下递归需要注意：1.下一个数的上界的选取，第一个数就取sqrt(N)，后面的数的上界是前一个数（由于对称性，只需要考虑降序排列的情况，否则计算量将急剧增加）。2.当sum+powP[i]&lt;=N时才向下递归 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int N,K,P;int powP[30];vector&lt;int&gt; bestSqe;vector&lt;int&gt; tmpSqe;int maxFacSum =-1;int bound;void powInit()&#123; powP[0] = 0;powP[1] = 1; int sum=1,i=2,p; while(sum&lt;=N) &#123; sum = 1; p = P; while(p--) sum*=i; powP[i] = sum; i++; &#125; bound = i-1;&#125;//k：第k个数//sum：前k个因数的P次方的和//facSum：前k个因数的和void dfs(int k,int sum,int facSum)&#123;// cout &lt;&lt; k &lt;&lt;" " &lt;&lt;sum &lt;&lt; " " &lt;&lt; facSum &lt;&lt; endl; if(k==K)&#123; if(sum == N&amp;&amp;facSum&gt;maxFacSum)&#123; bestSqe = tmpSqe; maxFacSum = facSum; &#125; return; &#125; //确保序列是递减的 int upBound = k==0?bound:tmpSqe[k-1]; for(int i = upBound;i&gt;=1;i--)&#123; if(sum+powP[i]&lt;=N)&#123; tmpSqe[k] = i; dfs(k+1,sum+powP[i],facSum+i); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; P; powInit(); tmpSqe.resize(K); dfs(0,0,0); if(maxFacSum==-1)&#123; cout &lt;&lt; "Impossible\n"; return 0; &#125; cout &lt;&lt; N &lt;&lt; " = "; for(int i=0;i&lt;bestSqe.size();i++)&#123; if(i!=0) cout &lt;&lt; " + "; cout &lt;&lt; bestSqe[i]&lt;&lt; "^" &lt;&lt; P; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1096,1097,1098,1099解题报告]]></title>
    <url>%2Fpost%2FPAT_1096_1097_1098_1099%2F</url>
    <content type="text"><![CDATA[1096 Consecutive Factors题目1096 Consecutive Factors （20 分） Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification:Each input file contains one test case, which gives the integer N (1&lt;N&lt;2^​31​). Output Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]factor[2]…*factor[k], where the factors are listed in increasing order, and 1 is NOT included. Sample Input:630Sample Output:3567 思路题目的意思是让找到一个整数最长的连续的因数（不是质因数）。一开始完全没头绪的题目，一开始想先分解成质因数，但是因数的组合也很麻烦……那就不妨暴力求解一下~虽然知道因子的上界是sqrt(N),但一开始偷懒先写的是N/2，果然有一个测试点过不了。然后想想，2^31数量级的情况下，sqrt(N)和N/2差了好多好多。改成sqrt(N)就果断过了。注意要用&lt;=,否则N=4的时候会出错。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt; factors;int main()&#123; int N; cin &gt;&gt; N; int maxNum = 1; factors.push_back(N); int sq = sqrt(N); //num个连续因子 for(int num = 1;num&lt;13;num++)&#123; //连续因子从start开始 bool end = false; for(int start = 2;start&lt;=sq;start++)&#123; //计算是否存在合适的连续因子 int product = 1; for(int i=start;i&lt;start+num;i++) product*=i; if(product&gt;N)&#123; end = true; break; &#125;else if(N%product==0)&#123; factors.clear(); for(int i = start;i&lt;start+num;i++) &#123; factors.push_back(i); &#125; maxNum = num; break; &#125; &#125; if(end) break; &#125; cout &lt;&lt; maxNum &lt;&lt; "\n"; for(int i=0;i&lt;factors.size();i++)&#123; if(i!=0) cout &lt;&lt;"*"; cout &lt;&lt; factors[i]; &#125; return 0;&#125; 1097 Deduplication on a Linked List题目1097 Deduplication on a Linked List （25 分）Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤10^5​​ ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Key Nextwhere Address is the position of the node, Key is an integer of which absolute value is no more than 10^4​, and Next is the position of the next node. Output Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:00100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854Sample Output:00100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 思路删除一个链表中绝对值相同的节点，只保留第一个。简单的链表删除，删除之后把删掉的节点记录在lastDelete中，然后删除下一个节点的时候，把lastdelete指向这个被删除的节点。最后把lastDelete指向-1。一开始输出的时候忘了把next也要填充到5位，而示例的输入输出又刚好next都是五位的……在这个坑爹的问题上卡了好久。为什么PAT的输入输出总是这么的让我崩溃。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Node&#123; int value; int next;&#125;;Node List[100010];set&lt;int&gt; s;int lastDelete = -1;int firstDelete = -1;void output(int root)&#123; int temp = root; while(temp!=-1)&#123; cout.width(5); cout.fill('0'); cout &lt;&lt; temp &lt;&lt; " " &lt;&lt; List[temp].value &lt;&lt; " " ; if(List[temp].next!=-1)&#123; cout.width(5); cout.fill('0'); &#125; cout &lt;&lt; List[temp].next &lt;&lt; "\n"; temp = List[temp].next; &#125;&#125;int main()&#123; int N,start; cin &gt;&gt; start &gt;&gt; N; int pos; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; pos; cin &gt;&gt; List[pos].value; cin &gt;&gt; List[pos].next; &#125; int pre = start; s.insert(abs(List[start].value)); while(List[pre].next!=-1)&#123; int now = List[pre].next; //无需删除，继续查找 if(s.count(abs(List[now].value))==0) &#123; s.insert(abs(List[now].value)); pre = now; &#125;else&#123;//删除节点// cout &lt;&lt; "delete: " &lt;&lt;now &lt;&lt; endl; List[pre].next = List[now].next; if(lastDelete==-1) &#123; firstDelete = now; &#125; else&#123; List[lastDelete].next = now; &#125; lastDelete = now; &#125; &#125; List[lastDelete].next = -1; output(start); output(firstDelete); return 0;&#125; 1098 Insertion or Heap Sort题目1098 Insertion or Heap Sort （25 分）According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification:For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0Sample Output 1:Insertion Sort1 2 3 5 7 8 9 4 6 0Sample Input 2:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9Sample Output 2:Heap Sort5 4 3 1 0 2 6 7 8 9 思路给出一个序列，及排序到一半的序列，判断到底是插入排序还是堆排序，然后再进行下一步。主要考察对插入排序及堆排序的熟悉程度。因为插入排序比较好写，所以就先一步一步的执行插入排序，和给定的序列进行比较，相同说明是插入排序，如果排序完成还不同说明是堆排序。判断出堆排序后，因为堆排序pop的每一个数都是堆中的最大值，所以堆排序序列后面的都是最大值，和之前插入排序已经排好的队列进行比较，就能找到排序进行到哪一步了，再进行一步排序就好。为了方便插入排序的比较和堆排序的下标运算，数组存放从1开始，0的值设为-1坐标标兵。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;int ori[110] = &#123;-1&#125;;int ins[110] = &#123;-1&#125;;int sorted[110] = &#123;-1&#125;;int N;//将第n个元素插入到前n-1个元素中合适的位置void Insertion(int arr[],int n)&#123; for(int i = n-1;i&gt;=0;i--)&#123; if(arr[n]&gt;arr[i])&#123; int temp = arr[n]; for(int j=n;j&gt;i+1;j--)&#123; arr[j] = arr[j-1]; &#125; arr[i+1] = temp; break; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N; for(int i=1;i&lt;=N;i++) &#123;cin &gt;&gt;ori[i];ins[i] = ori[i];&#125; for(int i=1;i&lt;=N;i++) cin &gt;&gt; sorted[i]; bool same; for(int j=2;j&lt;=N;j++)&#123; same = true; Insertion(ins,j);// for(int i=1;i&lt;=N;i++) cout &lt;&lt; ins[i] &lt;&lt; " ";// cout &lt;&lt; endl; for(int i=1;i&lt;=N;i++)&#123; if(ins[i]!=sorted[i])&#123; same = false; break; &#125; &#125; if(same)&#123; cout &lt;&lt; "Insertion Sort\n"; Insertion(ins,j+1); for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; ins[i]; &#125; return 0; &#125; &#125; int flag = N; for(;flag&gt;=1;flag--)&#123; if(sorted[flag]!=ins[flag]) break; &#125; int tem = sorted[flag]; sorted[flag] = sorted[1]; int prt = 1; while(prt*2&lt;flag)&#123; int chd = (prt*2+1==flag||sorted[prt*2]&gt;sorted[prt*2+1])?prt*2:prt*2+1; if(tem&gt;=sorted[chd]) break; sorted[prt] = sorted[chd];// cout &lt;&lt; prt &lt;&lt; " " &lt;&lt; chd &lt;&lt; endl; prt = chd; &#125; sorted[prt] = tem; cout &lt;&lt; "Heap Sort\n"; for(int i=1;i&lt;=N;i++)&#123; if(i!=1) cout &lt;&lt; " "; cout &lt;&lt; sorted[i]; &#125; return 0;&#125; 1099 Build A Binary Search Tree题目1099 Build A Binary Search Tree （30 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input:91 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42Sample Output:58 25 82 11 38 67 45 73 42 思路考察二叉树的操作。先用递归把各个节点的左右子树的数量算出来，再用递归把排序后的数字填入节点中。再用个队列层序遍历整棵树并输出。看了一下别人的答案发现，二叉搜索树的中序遍历原来就是按数值从小到大遍历一遍，那直接中序遍历填数值，层序遍历输出就好。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;struct Node&#123; int value; int left,right; int leftNum,rightNum;&#125;;Node Tree[110];int N;vector&lt;int&gt; v;int CalChildrenNum(int root)&#123; Tree[root].leftNum = Tree[root].left==-1?0:(CalChildrenNum(Tree[root].left)+1); Tree[root].rightNum = Tree[root].right==-1?0:(CalChildrenNum(Tree[root].right)+1);// cout &lt;&lt; "Children Number of " &lt;&lt; root &lt;&lt; " is" &lt;&lt; Tree[root].leftNum+Tree[root].rightNum &lt;&lt; endl; return Tree[root].leftNum+Tree[root].rightNum;&#125;void build(int root,int from)&#123; Tree[root].value = v[from + Tree[root].leftNum];// cout &lt;&lt; "root: " &lt;&lt; root &lt;&lt; " value:" &lt;&lt; Tree[root].value &lt;&lt; endl; if(Tree[root].left!=-1) build(Tree[root].left,from); if(Tree[root].right!=-1) build(Tree[root].right,from + Tree[root].leftNum+1);&#125;int main()&#123; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; Tree[i].left &gt;&gt; Tree[i].right; &#125; int tem; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; tem; v.push_back(tem); &#125; sort(v.begin(),v.end()); CalChildrenNum(0); build(0,0); queue&lt;int&gt; q; q.push(0); while(!q.empty())&#123; int p = q.front(); q.pop(); if(p!=0) cout &lt;&lt; " "; cout &lt;&lt; Tree[p].value; if(Tree[p].left!=-1) q.push(Tree[p].left); if(Tree[p].right!=-1) q.push(Tree[p].right); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fpost%2Ffirst_article%2F</url>
    <content type="text"><![CDATA[博客终于搭建完成了！经过千辛万苦（长达两天的努力），我的博客终于上线了！以后会在这里记录一些科研以及学习的心得。 让我先试着放张图片： 下面放一段代码12str = "Hello world!"print(str) 下面是一个表格 AND true false true true false false false false 1.hexo从零开始到搭建完整2.Hexo下的Markdown语法(GFM)写博客3.Hexo搭建的GitHub博客之优化大全4.Hexo 官网5.Next 使用文档]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
